/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2008-2012, Stephen Colebourne & Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.firas.datetime.format

import org.firas.datetime.*
import org.firas.datetime.chrono.ChronoLocalDate
import org.firas.datetime.chrono.Chronology
import org.firas.datetime.chrono.IsoChronology
import org.firas.datetime.temporal.ChronoField
import org.firas.datetime.temporal.TemporalAccessor
import org.firas.datetime.temporal.TemporalField
import org.firas.datetime.temporal.TemporalQueries
import org.firas.datetime.util.MathUtils
import org.firas.datetime.zone.ZoneId
import org.firas.datetime.zone.ZoneOffset
import org.firas.lang.insert
import org.firas.lang.setLength
import org.firas.math.BigDecimal
import org.firas.math.BigInteger
import org.firas.math.RoundingMode
import kotlin.math.absoluteValue

/**
 * Builder to create date-time formatters.
 *
 *
 * This allows a `DateTimeFormatter` to be created.
 * All date-time formatters are created ultimately using this builder.
 *
 *
 * The basic elements of date-time can all be added:
 *
 * * Value - a numeric value
 * * Fraction - a fractional value including the decimal place. Always use this when
 *   outputting fractions to ensure that the fraction is parsed correctly
 * * Text - the textual equivalent for the value
 * * OffsetId/Offset - the {@linkplain ZoneOffset zone offset}
 * * ZoneId - the {@linkplain ZoneId time-zone} id
 * * ZoneText - the name of the time-zone
 * * ChronologyId - the {@linkplain Chronology chronology} id
 * * ChronologyText - the name of the chronology
 * * Literal - a text literal
 * * Nested and Optional - formats can be nested or made optional
 *
 * In addition, any of the elements may be decorated by padding, either with spaces or any other character.
 *
 *
 * Finally, a shorthand pattern, mostly compatible with `java.text.SimpleDateFormat SimpleDateFormat`
 * can be used, see [.appendPattern(String)].
 * In practice, this simply parses the pattern and calls other methods on the builder.
 *
 * @implSpec
 * This class is a mutable builder intended for use from a single thread.
 *
 * @since Java 1.8
 * @author Wu Yuping (migrate to Kotlin)
 */
class DateTimeFormatterBuilder private constructor(
    val parent: DateTimeFormatterBuilder?,
    val optional: Boolean
) {
    constructor(): this(null, false)

    /**
     * The currently active builder, used by the outermost builder.
     */
    private var active = this

    /**
     * The list of printers that will be used.
     */
    private val printerParsers: MutableList<DateTimePrinterParser?> = ArrayList()

    /**
     * The width to pad the next field to.
     */
    private var padNextWidth: Int = 0

    /**
     * The character to pad the next field with.
     */
    private var padNextChar: Char = ' '

    /**
     * The index of the last variable width varue parser.
     */
    private var valueParserIndex = -1

    companion object {

        /** Map of letters to fields.  */
        private val FIELD_MAP: MutableMap<Char, TemporalField> = HashMap()

        init {
            // SDF = SimpleDateFormat
            FIELD_MAP.put('G', ChronoField.ERA)                       // SDF, LDML (different to both for 1/2 chars)
            FIELD_MAP.put('y', ChronoField.YEAR_OF_ERA)               // SDF, LDML
            FIELD_MAP.put('u', ChronoField.YEAR)                      // LDML (different in SDF)
            // TODO: FIELD_MAP.put('Q', IsoFields.QUARTER_OF_YEAR)             // LDML (removed quarter from 310)
            // TODO: FIELD_MAP.put('q', IsoFields.QUARTER_OF_YEAR)             // LDML (stand-alone)
            FIELD_MAP.put('M', ChronoField.MONTH_OF_YEAR)             // SDF, LDML
            FIELD_MAP.put('L', ChronoField.MONTH_OF_YEAR)             // SDF, LDML (stand-alone)
            FIELD_MAP.put('D', ChronoField.DAY_OF_YEAR)               // SDF, LDML
            FIELD_MAP.put('d', ChronoField.DAY_OF_MONTH)              // SDF, LDML
            FIELD_MAP.put('F', ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)  // SDF, LDML
            FIELD_MAP.put('E', ChronoField.DAY_OF_WEEK)               // SDF, LDML (different to both for 1/2 chars)
            FIELD_MAP.put('c', ChronoField.DAY_OF_WEEK)               // LDML (stand-alone)
            FIELD_MAP.put('e', ChronoField.DAY_OF_WEEK)               // LDML (needs localized week number)
            FIELD_MAP.put('a', ChronoField.AMPM_OF_DAY)               // SDF, LDML
            FIELD_MAP.put('H', ChronoField.HOUR_OF_DAY)               // SDF, LDML
            FIELD_MAP.put('k', ChronoField.CLOCK_HOUR_OF_DAY)         // SDF, LDML
            FIELD_MAP.put('K', ChronoField.HOUR_OF_AMPM)              // SDF, LDML
            FIELD_MAP.put('h', ChronoField.CLOCK_HOUR_OF_AMPM)        // SDF, LDML
            FIELD_MAP.put('m', ChronoField.MINUTE_OF_HOUR)            // SDF, LDML
            FIELD_MAP.put('s', ChronoField.SECOND_OF_MINUTE)          // SDF, LDML
            FIELD_MAP.put('S', ChronoField.NANO_OF_SECOND)            // LDML (SDF uses milli-of-second number)
            FIELD_MAP.put('A', ChronoField.MILLI_OF_DAY)              // LDML
            FIELD_MAP.put('n', ChronoField.NANO_OF_SECOND)            // 310 (proposed for LDML)
            FIELD_MAP.put('N', ChronoField.NANO_OF_DAY)               // 310 (proposed for LDML)
            // TODO: FIELD_MAP.put('g', JulianFields.MODIFIED_JULIAN_DAY)
            // 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4
            // 310 - Z - matches SimpleDateFormat and LDML
            // 310 - V - time-zone id, matches LDML
            // 310 - v - general timezone names, not matching exactly with LDML because LDML specify to fall back
            //           to 'VVVV' if general-nonlocation unavailable but here it's not falling back because of lack of data
            // 310 - p - prefix for padding
            // 310 - X - matches LDML, almost matches SDF for 1, exact match 2&3, extended 4&5
            // 310 - x - matches LDML
            // 310 - w, W, and Y are localized forms matching LDML
            // LDML - U - cycle year name, not supported by 310 yet
            // LDML - l - deprecated
            // LDML - j - not relevant
        }

        /**
         * Converts the given FormatStyle to the java.text.DateFormat style.
         *
         * @param style  the FormatStyle style
         * @return the int style, or -1 if style is null, indicating un-required
         */
        private fun convertStyle(style: FormatStyle?): Int {
            return style?.ordinal ?: -1
            // indices happen to align
        }

        //-----------------------------------------------------------------------
        /**
         * Strategy for formatting/parsing date-time information.
         *
         *
         * The printer may format any part, or the whole, of the input date-time object.
         * Typically, a complete format is constructed from a number of smaller
         * units, each outputting a single field.
         *
         *
         * The parser may parse any piece of text from the input, storing the result
         * in the context. Typically, each individual parser will just parse one
         * field, such as the day-of-month, storing the value in the context.
         * Once the parse is complete, the caller will then resolve the parsed values
         * to create the desired object, such as a `LocalDate`.
         *
         *
         * The parse position will be updated during the parse. Parsing will start at
         * the specified index and the return value specifies the new parse position
         * for the next parser. If an error occurs, the returned index will be negative
         * and will have the error position encoded using the complement operator.
         *
         * @implSpec
         * This interface must be implemented with care to ensure other classes operate correctly.
         * All implementations that can be instantiated must be final, immutable and thread-safe.
         *
         *
         * The context is not a thread-safe object and a new instance will be created
         * for each format that occurs. The context must not be stored in an instance
         * variable or shared with any other threads.
         */
        internal interface DateTimePrinterParser {
            /**
             * Prints the date-time object to the buffer.
             *
             *
             * The context holds information to use during the format.
             * It also contains the date-time information to be printed.
             *
             *
             * The buffer must not be mutated beyond the content controlled by the implementation.
             *
             * @param context  the context to format using, not null
             * @param buf  the buffer to append to, not null
             * @return false if unable to query the value from the date-time, true otherwise
             * @throws DateTimeException if the date-time cannot be printed successfully
             */
            fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean

            /**
             * Parses text into date-time information.
             *
             *
             * The context holds information to use during the parse.
             * It is also used to store the parsed date-time information.
             *
             * @param context  the context to use and parse into, not null
             * @param text  the input text to parse, not null
             * @param position  the position to start parsing at, from 0 to the text length
             * @return the new parse position, where negative means an error with the
             * error position encoded using the complement ~ operator
             * @throws NullPointerException if the context or text is null
             * @throws IndexOutOfBoundsException if the position is invalid
             */
            fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int
        }

        //-----------------------------------------------------------------------
        /**
         * Composite printer and parser.
         */
        internal class CompositePrinterParser(
            private val printerParsers: Array<DateTimePrinterParser>,
            private val optional: Boolean
        ) : DateTimePrinterParser {

            internal constructor(
                printerParsers: List<DateTimePrinterParser>,
                optional: Boolean
            ) : this(printerParsers.toTypedArray<DateTimePrinterParser>(), optional)

            /**
             * Returns a copy of this printer-parser with the optional flag changed.
             *
             * @param optional  the optional flag to set in the copy
             * @return the new printer-parser, not null
             */
            fun withOptional(optional: Boolean): CompositePrinterParser {
                return if (optional == this.optional) {
                    this
                } else CompositePrinterParser(this.printerParsers, optional)
            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val length = buf.length
                if (this.optional) {
                    context.startOptional()
                }
                try {
                    for (pp in this.printerParsers) {
                        if (!pp.format(context, buf)) {
                            buf.setLength(length)  // reset buffer
                            return true
                        }
                    }
                } finally {
                    if (optional) {
                        context.endOptional()
                    }
                }
                return true
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                var position = position
                if (optional) {
                    context.startOptional()
                    var pos = position
                    for (pp in this.printerParsers) {
                        pos = pp.parse(context, text, pos)
                        if (pos < 0) {
                            context.endOptional(false)
                            return position  // return original position
                        }
                    }
                    context.endOptional(true)
                    return pos
                } else {
                    for (pp in this.printerParsers) {
                        position = pp.parse(context, text, position)
                        if (position < 0) {
                            break
                        }
                    }
                    return position
                }
            }

            override fun toString(): String {
                val buf = StringBuilder()
                buf.append(if (optional) "[" else "(")
                for (pp in printerParsers) {
                    buf.append(pp)
                }
                buf.append(if (optional) "]" else ")")
                return buf.toString()
            }
        } // internal class CompositePrinterParser

        //-----------------------------------------------------------------------
        /**
         * Pads the output to a fixed width.
         */
        internal class PadPrinterParserDecorator
        /**
         * Constructor.
         *
         * @param printerParser  the printer, not null
         * @param padWidth  the width to pad to, 1 or greater
         * @param padChar  the pad character
         */
            (
            private val printerParser: DateTimePrinterParser,
            private val padWidth: Int,
            private val padChar: Char
        )// input checked by DateTimeFormatterBuilder
            : DateTimePrinterParser {

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val preLen = buf.length
                if (!printerParser.format(context, buf)) {
                    return false
                }
                val len = buf.length - preLen
                if (len > padWidth) {
                    throw DateTimeException(
                        "Cannot print as output of $len characters exceeds pad width of $padWidth"
                    )
                }

                val padString = StringBuilder()
                for (i in 0 until padWidth - len) {
                    padString.append(padChar)
                }
                buf.insert(preLen, padString)
                return true
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                var text = text
                // cache context before changed by decorated parser
                val strict = context.strict
                // parse
                if (position > text.length) {
                    throw IndexOutOfBoundsException()
                }
                if (position == text.length) {
                    return position.inv()  // no more characters in the string
                }
                var endPos = position + padWidth
                if (endPos > text.length) {
                    if (strict) {
                        return position.inv()  // not enough characters in the string to meet the parse width
                    }
                    endPos = text.length
                }
                var pos = position
                while (pos < endPos && context.charEquals(text[pos], padChar)) {
                    pos += 1
                }
                text = text.subSequence(0, endPos)
                val resultPos = printerParser.parse(context, text, pos)
                return if (resultPos != endPos && strict) {
                    (position + pos).inv()  // parse of decorated field didn't parse to the end
                } else resultPos
            }

            override fun toString(): String {
                return "Pad(" + printerParser + "," + padWidth + if (padChar == ' ') ")" else ",'$padChar')"
            }
        }

        //-----------------------------------------------------------------------
        /**
         * Enumeration to apply simple parse settings.
         */
        internal enum class SettingsParser : DateTimePrinterParser {
            SENSITIVE,
            INSENSITIVE,
            STRICT,
            LENIENT;

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                return true  // nothing to do here
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                // using ordinals to avoid javac synthetic inner class
                when (ordinal) {
                    0 -> context.caseSensitive = true
                    1 -> context.caseSensitive = false
                    2 -> context.strict = true
                    3 -> context.strict = false
                }
                return position
            }

            override fun toString(): String {
                // using ordinals to avoid javac synthetic inner class
                when (ordinal) {
                    0 -> return "ParseCaseSensitive(true)"
                    1 -> return "ParseCaseSensitive(false)"
                    2 -> return "ParseStrict(true)"
                    3 -> return "ParseStrict(false)"
                }
                throw IllegalStateException("Unreachable")
            }
        } // internal enum class SettingsParser

        //-----------------------------------------------------------------------
        /**
         * Defaults a value into the parse if not currently present.
         */
        internal class DefaultValueParser(private val field: TemporalField, private val value: Long) :
            DateTimePrinterParser {

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                return true
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                if (context.getParsed(field) == null) {
                    context.setParsedField(field, value, position, position)
                }
                return position
            }
        } // internal class DefaultValueParser

        //-----------------------------------------------------------------------
        /**
         * Prints or parses a character literal.
         */
        internal class CharLiteralPrinterParser(private val literal: Char) : DateTimePrinterParser {

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                buf.append(literal)
                return true
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                val length = text.length
                if (position == length) {
                    return position.inv()
                }
                val ch = text[position]
                if (ch != literal) {
                    if (context.caseSensitive || ch.toUpperCase() != literal.toUpperCase() &&
                            ch.toLowerCase() != literal.toLowerCase()) {
                        return position.inv()
                    }
                }
                return position + 1
            }

            override fun toString(): String {
                return if (literal == '\'') {
                    "''"
                } else "'$literal'"
            }
        } // internal class CharLiteralPrinterParser

        //-----------------------------------------------------------------------
        /**
         * Prints and parses a numeric date-time field with optional padding.
         */
        internal open class NumberPrinterParser protected constructor(
            val field: TemporalField,
            val minWidth: Int,
            val maxWidth: Int,
            internal val signStyle: SignStyle,
            val subsequentWidth: Int
        ): DateTimePrinterParser {

            internal constructor(field: TemporalField,
                                 minWidth: Int, maxWidth: Int, signStyle: SignStyle):
                    this(field, minWidth, maxWidth, signStyle, 0)

            companion object {
                /**
                 * Array of 10 to the power of n.
                 */
                internal val EXCEED_POINTS = longArrayOf(
                    0L,
                    10L,
                    100L,
                    1000L,
                    10000L,
                    100000L,
                    1000000L,
                    10000000L,
                    100000000L,
                    1000000000L,
                    10000000000L
                )
            } // NumberPrinterParser.Companion

            /**
             * Returns a new instance with fixed width flag set.
             *
             * @return a new updated printer-parser, not null
             */
            internal open fun withFixedWidth(): NumberPrinterParser {
                if (subsequentWidth == -1) {
                    return this
                }
                return NumberPrinterParser(field, minWidth, maxWidth, signStyle, -1)
            }

            /**
             * Returns a new instance with an updated subsequent width.
             *
             * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
             * @return a new updated printer-parser, not null
             */
            internal open fun withSubsequentWidth(subsequentWidth: Int): NumberPrinterParser {
                return NumberPrinterParser(field, minWidth, maxWidth, signStyle, this.subsequentWidth + subsequentWidth)
            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val valueLong = context.getValue(field)
                if (valueLong == null) {
                    return false
                }
                val value = getValue(context, valueLong)
                val decimalStyle = context.getDecimalStyle()
                var str = if (value == Long.MIN_VALUE) "9223372036854775808"
                        else value.absoluteValue.toString()
                if (str.length > maxWidth) {
                    throw DateTimeException(
                        "Field $field" +
                                " cannot be printed as the value $value" +
                                " exceeds the maximum print width of $maxWidth"
                    )
                }
                str = decimalStyle.convertNumberToI18N(str)

                if (value >= 0) {
                    when (signStyle) {
                        SignStyle.EXCEEDS_PAD ->
                            if (minWidth < 19 && value >= EXCEED_POINTS[minWidth]) {
                                buf.append(decimalStyle.getPositiveSign())
                            }
                        SignStyle.ALWAYS ->
                            buf.append(decimalStyle.getPositiveSign())
                    }
                } else {
                    when (signStyle) {
                        SignStyle.NORMAL, SignStyle.EXCEEDS_PAD, SignStyle.ALWAYS ->
                            buf.append(decimalStyle.getNegativeSign())
                        SignStyle.NOT_NEGATIVE ->
                            throw DateTimeException(
                                "Field $field" +
                                        " cannot be printed as the value $value" +
                                        " cannot be negative according to the SignStyle"
                            )
                    }
                }
                for (i in 0 until minWidth - str.length) {
                    buf.append(decimalStyle.getZeroDigit())
                }
                buf.append(str)
                return true
            }

            /**
             * Gets the value to output.
             *
             * @param context  the context
             * @param value  the value of the field, not null
             * @return the value
             */
            internal open fun getValue(context: DateTimePrintContext, value: Long): Long {
                return value
            }

            /**
             * For NumberPrinterParser, the width is fixed depending on the
             * minWidth, maxWidth, signStyle and whether subsequent fields are fixed.
             * @param context the context
             * @return true if the field is fixed width
             * @see DateTimeFormatterBuilder.appendValue
             */
            internal open fun isFixedWidth(context: DateTimeParseContext): Boolean {
                return subsequentWidth == -1 ||
                        subsequentWidth > 0 && minWidth == maxWidth && signStyle == SignStyle.NOT_NEGATIVE
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                var position = position
                val length = text.length
                if (position == length) {
                    return position.inv()
                }
                val sign = text[position]  // IOOBE if invalid position
                var negative = false
                var positive = false
                if (sign == context.getDecimalStyle().getPositiveSign()) {
                    if (!signStyle.parse(true, context.strict, minWidth == maxWidth)) {
                        return position.inv()
                    }
                    positive = true
                    position += 1
                } else if (sign == context.getDecimalStyle().getNegativeSign()) {
                    if (!signStyle.parse(false, context.strict, minWidth == maxWidth)) {
                        return position.inv()
                    }
                    negative = true
                    position += 1
                } else {
                    if (signStyle == SignStyle.ALWAYS && context.strict) {
                        return position.inv()
                    }
                }
                val effMinWidth = if (context.strict || isFixedWidth(context)) minWidth else 1
                val minEndPos = position + effMinWidth
                if (minEndPos > length) {
                    return position.inv()
                }
                var effMaxWidth = if (context.strict || isFixedWidth(context)) maxWidth else 9 +
                        maxOf(subsequentWidth, 0)
                var total = 0L
                var totalBig: BigInteger? = null
                var pos = position
                for (pass in 0 until 2) {
                    val maxEndPos = minOf(pos + effMaxWidth, length)
                    while (pos < maxEndPos) {
                        val ch = text[pos]
                        pos += 1
                        val digit = context.getDecimalStyle().convertToDigit(ch)
                        if (digit < 0) {
                            pos -= 1
                            if (pos < minEndPos) {
                                return position.inv()  // need at least min width digits
                            }
                            break
                        }
                        if ((pos - position) > 18) {
                            if (totalBig == null) {
                                totalBig = BigInteger.valueOf(total)
                            }
                            totalBig = totalBig * BigInteger.TEN + BigInteger.valueOf(digit.toLong())
                        } else {
                            total = total * 10 + digit
                        }
                    }
                    if (subsequentWidth > 0 && pass == 0) {
                        // re-parse now we know the correct width
                        val parseLen = pos -position
                        effMaxWidth = maxOf(effMinWidth, parseLen - subsequentWidth)
                        pos = position
                        total = 0
                        totalBig = null
                    } else {
                        break
                    }
                }
                if (negative) {
                    if (totalBig != null) {
                        if (totalBig == BigInteger.ZERO && context.strict) {
                            return (position-1).inv()  // minus zero not allowed
                        }
                        totalBig = -totalBig
                    } else {
                        if (total == 0L && context.strict) {
                            return (position-1).inv()  // minus zero not allowed
                        }
                        total = -total
                    }
                } else if (signStyle == SignStyle.EXCEEDS_PAD && context.strict) {
                    val parseLen = pos -position
                    if (positive) {
                        if (parseLen <= minWidth) {
                            return (position-1).inv()  // '+' only parsed if minWidth exceeded
                        }
                    } else {
                        if (parseLen > minWidth) {
                            return position.inv()  // '+' must be parsed if minWidth exceeded
                        }
                    }
                }
                if (totalBig != null) {
                    if (totalBig.bitLength() > 63) {
                        // overflow, parse 1 less digit
                        totalBig /= BigInteger.TEN
                        pos -= 1
                    }
                    return setValue(context, totalBig.toLong(), position, pos)
                }
                return setValue(context, total, position, pos)
            }

            /**
             * Stores the value.
             *
             * @param context  the context to store into, not null
             * @param value  the value
             * @param errorPos  the position of the field being parsed
             * @param successPos  the position after the field being parsed
             * @return the new position
             */
            internal open fun setValue(context: DateTimeParseContext,
                                  value: Long, errorPos: Int, successPos: Int): Int {
                return context.setParsedField(field, value, errorPos, successPos)
            }

            override fun toString(): String {
                if (minWidth == 1 && maxWidth == 19 && signStyle == SignStyle.NORMAL) {
                    return "Value($field)"
                }
                if (minWidth == maxWidth && signStyle == SignStyle.NOT_NEGATIVE) {
                    return "Value($field,$minWidth)"
                }
                return "Value($field,$minWidth,$maxWidth,$signStyle)"
            }
        } // internal class NumberPrinterParser

        //-----------------------------------------------------------------------
        /**
         * Prints and parses a reduced numeric date-time field.
         */
        internal class ReducedPrinterParser private constructor(
            field: TemporalField,
            minWidth: Int,
            maxWidth: Int,
            private val baseValue: Int,
            private val baseDate: ChronoLocalDate?,
            subsequentWidth: Int
        ): NumberPrinterParser(field, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth) {

            /**
             * Constructor.
             *
             * @param field  the field to format, validated not null
             * @param minWidth  the minimum field width, from 1 to 10
             * @param maxWidth  the maximum field width, from 1 to 10
             * @param baseValue  the base value
             * @param baseDate  the base date
             */
            internal constructor(
                field: TemporalField, minWidth: Int, maxWidth: Int,
                baseValue: Int, baseDate: ChronoLocalDate?
            ): this(field, minWidth, maxWidth, baseValue, baseDate, 0) {
                if (minWidth < 1 || minWidth > 10) {
                    throw IllegalArgumentException("The minWidth must be from 1 to 10 inclusive but was $minWidth")
                }
                if (maxWidth < 1 || maxWidth > 10) {
                    throw IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was $minWidth")
                }
                if (maxWidth < minWidth) {
                    throw IllegalArgumentException(
                        "Maximum width must exceed or equal the minimum width but " +
                                maxWidth + " < " + minWidth
                    )
                }
                if (baseDate == null) {
                    if (!field.range().isValidValue(baseValue.toLong())) {
                        throw IllegalArgumentException("The base value must be within the range of the field")
                    }
                    if ((baseValue.toLong() + DateTimeFormatterBuilder.Companion.NumberPrinterParser.EXCEED_POINTS[maxWidth]) > Int.MAX_VALUE) {
                        throw DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int")
                    }
                }
            }

            companion object {
                /**
                 * The base date for reduced value parsing.
                 */
                val BASE_DATE = LocalDate.of(2000, 1, 1)
            }

            override fun getValue(context: DateTimePrintContext, value: Long): Long {
                val absValue = value.absoluteValue
                var baseValue = this.baseValue
                if (baseDate != null) {
                    val chrono = Chronology.from(context.temporal!!)
                    baseValue = chrono.date(baseDate).get(field)
                }
                if (value >= baseValue && value < baseValue + EXCEED_POINTS[minWidth]) {
                    // Use the reduced value if it fits in minWidth
                    return absValue % EXCEED_POINTS[minWidth]
                }
                // Otherwise truncate to fit in maxWidth
                return absValue % EXCEED_POINTS[maxWidth]
            }

            override fun setValue(
                context: DateTimeParseContext, value: Long,
                errorPos: Int, successPos: Int
            ): Int {
                var value = value
                var baseValue = this.baseValue
                if (baseDate != null) {
                    val chrono = context.getEffectiveChronology()
                    baseValue = chrono.date(baseDate).get(field)

                    // In case the Chronology is changed later, add a callback when/if it changes
                    val initialValue = value
                    context.addChronoChangedListener { _unused: Chronology ->
                        /* Repeat the set of the field using the current Chronology
                         * The success/error position is ignored because the value is
                         * intentionally being overwritten.
                         */
                        setValue(context, initialValue, errorPos, successPos)
                    }
                }
                val parseLen = successPos - errorPos
                if (parseLen == minWidth && value >= 0) {
                    val range = EXCEED_POINTS[minWidth]
                    val lastPart = baseValue % range
                    val basePart = baseValue - lastPart
                    if (baseValue > 0) {
                        value = basePart + value
                    } else {
                        value = basePart - value
                    }
                    if (value < baseValue) {
                        value += range
                    }
                }
                return context.setParsedField(field, value, errorPos, successPos)
            }

            /**
             * Returns a new instance with fixed width flag set.
             *
             * @return a new updated printer-parser, not null
             */
            override fun withFixedWidth(): ReducedPrinterParser {
                return if (subsequentWidth == -1) {
                    this
                } else ReducedPrinterParser(field, minWidth, maxWidth, baseValue, baseDate, -1)
            }

            /**
             * Returns a new instance with an updated subsequent width.
             *
             * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
             * @return a new updated printer-parser, not null
             */
            override fun withSubsequentWidth(subsequentWidth: Int): ReducedPrinterParser {
                return ReducedPrinterParser(
                    field, minWidth, maxWidth, baseValue, baseDate,
                    this.subsequentWidth + subsequentWidth
                )
            }

            /**
             * For a ReducedPrinterParser, fixed width is false if the mode is strict,
             * otherwise it is set as for NumberPrinterParser.
             * @param context the context
             * @return if the field is fixed width
             * @see DateTimeFormatterBuilder.appendValueReduced
             */
            override fun isFixedWidth(context: DateTimeParseContext): Boolean {
                return if (!context.strict) {
                    false
                } else super.isFixedWidth(context)
            }

            override fun toString(): String {
                return "ReducedValue($field,$minWidth,$maxWidth," +
                        (baseDate?: baseValue) + ")"
            }
        } // internal class ReducedPrinterParser

        /**
         * Prints and parses a numeric date-time field with optional padding.
         */
        internal class FractionPrinterParser private constructor(
            field: TemporalField,
            minWidth: Int,
            maxWidth: Int,
            private val decimalPoint: Boolean,
            subsequentWidth: Int
        ): NumberPrinterParser(field, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth) {

            /**
             * Constructor.
             *
             * @param field  the field to output, not null
             * @param minWidth  the minimum width to output, from 0 to 9
             * @param maxWidth  the maximum width to output, from 0 to 9
             * @param decimalPoint  whether to output the localized decimal point symbol
             */
            internal constructor(
                field: TemporalField,
                minWidth: Int,
                maxWidth: Int,
                decimalPoint: Boolean
            ): this(field, minWidth, maxWidth, decimalPoint, 0) {
                if (!field.range().isFixed()) {
                    throw IllegalArgumentException("Field must have a fixed set of values: $field")
                }
                if (minWidth < 0 || minWidth > 9) {
                    throw IllegalArgumentException(
                            "Minimum width must be from 0 to 9 inclusive but was $minWidth")
                }
                if (maxWidth < 1 || maxWidth > 9) {
                    throw IllegalArgumentException(
                            "Maximum width must be from 1 to 9 inclusive but was $maxWidth")
                }
                if (maxWidth < minWidth) {
                    throw IllegalArgumentException(
                            "Maximum width must exceed or equal the minimum width but " +
                            maxWidth + " < " + minWidth)
                }
            }

            /**
             * Returns a new instance with fixed width flag set.
             *
             * @return a new updated printer-parser, not null
             */
            override fun withFixedWidth(): FractionPrinterParser {
                return if (subsequentWidth == -1) {
                    this
                } else FractionPrinterParser(field, minWidth, maxWidth, decimalPoint, -1)
            }

            /**
             * Returns a new instance with an updated subsequent width.
             *
             * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
             * @return a new updated printer-parser, not null
             */
            override fun withSubsequentWidth(subsequentWidth: Int): FractionPrinterParser {
                return FractionPrinterParser(
                    field,
                    minWidth,
                    maxWidth,
                    decimalPoint,
                    this.subsequentWidth + subsequentWidth
                )
            }

            /**
             * For FractionPrinterPrinterParser, the width is fixed if context is sttrict,
             * minWidth equal to maxWidth and decimalpoint is absent.
             * @param context the context
             * @return if the field is fixed width
             * @see DateTimeFormatterBuilder.appendValueFraction
             */
            override fun isFixedWidth(context: DateTimeParseContext): Boolean {
                return context.strict && this.minWidth == this.maxWidth && !this.decimalPoint
            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val value = context.getValue(field) ?: return false
                val decimalStyle = context.getDecimalStyle()
                var fraction = convertToFraction(value)
                if (fraction.scale() == 0) {  // scale is zero if value is zero
                    if (this.minWidth > 0) {
                        if (this.decimalPoint) {
                            buf.append(decimalStyle.getDecimalSeparator())
                        }
                        for (i in 0 until this.minWidth) {
                            buf.append(decimalStyle.getZeroDigit())
                        }
                    }
                } else {
                    val outputScale = minOf(maxOf(fraction.scale(), this.minWidth), this.maxWidth)
                    fraction = fraction.setScale(outputScale, RoundingMode.FLOOR)
                    var str = fraction.toPlainString().substring(2)
                    str = decimalStyle.convertNumberToI18N(str)
                    if (this.decimalPoint) {
                        buf.append(decimalStyle.getDecimalSeparator())
                    }
                    buf.append(str)
                }
                return true
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                var position = position
                val effectiveMin = if (context.strict || isFixedWidth(context)) this.minWidth else 0
                val effectiveMax = if (context.strict || isFixedWidth(context)) this.maxWidth else 9
                val length = text.length
                if (position == length) {
                    // valid if whole field is optional, invalid if minimum width
                    return if (effectiveMin > 0) position.inv() else position
                }
                if (this.decimalPoint) {
                    if (text[position] != context.getDecimalStyle().getDecimalSeparator()) {
                        // valid if whole field is optional, invalid if minimum width
                        return if (effectiveMin > 0) position.inv() else position
                    }
                    position += 1
                }
                val minEndPos = position + effectiveMin
                if (minEndPos > length) {
                    return position.inv()  // need at least min width digits
                }
                val maxEndPos = minOf(position + effectiveMax, length)
                var total = 0  // can use int because we are only parsing up to 9 digits
                var pos = position
                while (pos < maxEndPos) {
                    val ch = text[pos++]
                    val digit = context.getDecimalStyle().convertToDigit(ch)
                    if (digit < 0) {
                        if (pos < minEndPos) {
                            return position.inv()  // need at least min width digits
                        }
                        pos -= 1
                        break
                    }
                    total = total * 10 + digit
                }
                val fraction = BigDecimal(total).movePointLeft(pos - position)
                val value = convertFromFraction(fraction)
                return context.setParsedField(this.field, value, position, pos)
            }

            /**
             * Converts a value for this field to a fraction between 0 and 1.
             *
             *
             * The fractional value is between 0 (inclusive) and 1 (exclusive).
             * It can only be returned if the [value range][org.firas.datetime.temporal.TemporalField.range] is fixed.
             * The fraction is obtained by calculation from the field range using 9 decimal
             * places and a rounding mode of [FLOOR][RoundingMode.FLOOR].
             * The calculation is inaccurate if the values do not run continuously from smallest to largest.
             *
             *
             * For example, the second-of-minute value of 15 would be returned as 0.25,
             * assuming the standard definition of 60 seconds in a minute.
             *
             * @param value  the value to convert, must be valid for this rule
             * @return the value as a fraction within the range, from 0 to 1, not null
             * @throws DateTimeException if the value cannot be converted to a fraction
             */
            private fun convertToFraction(value: Long): BigDecimal {
                val range = field.range()
                range.checkValidValue(value, field)
                val minBD = BigDecimal.valueOf(range.getMinimum())
                val rangeBD = BigDecimal.valueOf(range.getMaximum()) - minBD + BigDecimal.ONE
                val valueBD = BigDecimal.valueOf(value) - minBD
                val fraction = valueBD.divide(rangeBD, 9, RoundingMode.FLOOR)
                // stripTrailingZeros bug
                return if (fraction.compareTo(BigDecimal.ZERO) == 0) BigDecimal.ZERO
                        else fraction.stripTrailingZeros()
            }

            /**
             * Converts a fraction from 0 to 1 for this field to a value.
             *
             *
             * The fractional value must be between 0 (inclusive) and 1 (exclusive).
             * It can only be returned if the [value range][java.time.temporal.TemporalField.range] is fixed.
             * The value is obtained by calculation from the field range and a rounding
             * mode of [FLOOR][RoundingMode.FLOOR].
             * The calculation is inaccurate if the values do not run continuously from smallest to largest.
             *
             *
             * For example, the fractional second-of-minute of 0.25 would be converted to 15,
             * assuming the standard definition of 60 seconds in a minute.
             *
             * @param fraction  the fraction to convert, not null
             * @return the value of the field, valid for this rule
             * @throws DateTimeException if the value cannot be converted
             */
            private fun convertFromFraction(fraction: BigDecimal): Long {
                val range = field.range()
                val minBD = BigDecimal.valueOf(range.getMinimum())
                val rangeBD = BigDecimal.valueOf(range.getMaximum()) - minBD + BigDecimal.ONE
                val valueBD = fraction.times(rangeBD).setScale(0, RoundingMode.FLOOR) + minBD
                return valueBD.longValueExact()
            }

            override fun toString(): String {
                val decimal = if (decimalPoint) ",DecimalPoint" else ""
                return "Fraction($field,$minWidth,$maxWidth$decimal)"
            }
        } // internal class FractionPrinterParser

        /**
         * Prints or parses field text.
         */
        internal class TextPrinterParser internal constructor(
            private val field: TemporalField,
            private val textStyle: TextStyle,
            private val provider: DateTimeTextProvider
        ): DateTimePrinterParser {
            /**
             * The cached number printer parser.
             * Immutable and volatile, so no synchronization needed.
             */
            private var numberPrinterParser: NumberPrinterParser? = null

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val value = context.getValue(field)
                if (value == null) {
                    return false
                }
                var text: String
                val chrono: Chronology? = context.temporal!!.query(TemporalQueries.CHRONO)
                if (chrono == null || chrono == IsoChronology.INSTANCE) {
                    text = provider.getText(field, value, textStyle, context.getLocale())
                } else {
                    text = provider.getText(chrono, field, value, textStyle, context.getLocale())
                }
                if (text == null) {
                    return numberPrinterParser().format(context, buf)
                }
                buf.append(text)
                return true
            }

            override fun parse(context: DateTimeParseContext, parseText: CharSequence, position: Int): Int {
                val length = parseText.length
                if (position < 0 || position > length) {
                    throw IndexOutOfBoundsException()
                }
                val style = if (context.strict) textStyle else null
                val chrono = context.getEffectiveChronology()
                val it: Iterator<Map.Entry<String, Long>> = if (chrono == IsoChronology.INSTANCE) {
                    provider.getTextIterator(field, style, context.getLocale())
                } else {
                    provider.getTextIterator(chrono, field, style, context.getLocale())
                }
                if (it != null) {
                    while (it.hasNext()) {
                        val entry = it.next()
                        val itText = entry.key
                        if (context.subSequenceEquals(itText, 0, parseText, position, itText.length)) {
                            return context.setParsedField(field, entry.value, position, position + itText.length)
                        }
                    }
                    if (field == ChronoField.ERA && !context.strict) {
                        // parse the possible era name from era.toString()
                        val eras = chrono.eras()
                        for (era in eras) {
                            val name = era.toString()
                            if (context.subSequenceEquals(name, 0, parseText, position, name.length)) {
                                return context.setParsedField(field, era.getValue(), position, position + name.length())
                            }
                        }
                    }
                    if (context.strict) {
                        return position.inv()
                    }
                }
                return numberPrinterParser().parse(context, parseText, position)
            }

            /**
             * Create and cache a number printer parser.
             * @return the number printer parser for this field, not null
             */
            private fun numberPrinterParser(): NumberPrinterParser {
                if (numberPrinterParser == null) {
                    numberPrinterParser = NumberPrinterParser(field, 1, 19, SignStyle.NORMAL)
                }
                return numberPrinterParser!!
            }

            override fun toString(): String {
                if (textStyle == TextStyle.FULL) {
                    return "Text($field)"
                }
                return "Text($field,$textStyle)"
            }
        } // internal class TextPrinterParser

        /**
         * Prints or parses an ISO-8601 instant.
         */
        internal class InstantPrinterParser internal constructor(
            private val fractionalDigits: Int
        ): DateTimePrinterParser {
            companion object {
                // days in a 400 year cycle = 146097
                // days in a 10,000 year cycle = 146097 * 25
                // seconds per day = 86400
                private const val SECONDS_PER_10000_YEARS = 146097L * 25L * 86400L
                private const val SECONDS_0000_TO_1970 = ((146097L * 5L) - (30L * 365L + 7L)) * 86400L
            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX
                val inSecs = context.getValue(ChronoField.INSTANT_SECONDS)
                var inNanos: Long? = null
                if (context.temporal!!.isSupported(ChronoField.NANO_OF_SECOND)) {
                    inNanos = context.temporal.getLong(ChronoField.NANO_OF_SECOND)
                }
                if (inSecs == null) {
                    return false
                }
                var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos ?: 0)
                // format mostly using LocalDateTime.toString
                if (inSecs >= -SECONDS_0000_TO_1970) {
                    // current era
                    val zeroSecs = inSecs - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970
                    val hi = MathUtils.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1
                    val lo = MathUtils.floorMod(zeroSecs, SECONDS_PER_10000_YEARS)
                    val ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC)
                    if (hi > 0) {
                        buf.append('+').append(hi)
                    }
                    buf.append(ldt)
                    if (ldt.getSecond() == 0) {
                        buf.append(":00")
                    }
                } else {
                    // before current era
                    val zeroSecs = inSecs + SECONDS_0000_TO_1970
                    val hi = zeroSecs / SECONDS_PER_10000_YEARS
                    val lo = zeroSecs % SECONDS_PER_10000_YEARS
                    val ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC)
                    val pos = buf.length
                    buf.append(ldt)
                    if (ldt.getSecond() == 0) {
                        buf.append(":00")
                    }
                    if (hi < 0) {
                        if (ldt.getYear() == -10000) {
                            buf.replace(pos, pos + 2, (hi - 1).toString())
                        } else if (lo == 0L) {
                            buf.insert(pos, hi.toString())
                        } else {
                            buf.insert(pos + 1, hi.absoluteValue.toString())
                        }
                    }
                }
                // add fraction
                if (fractionalDigits < 0 && inNano > 0 || fractionalDigits > 0) {
                    buf.append('.')
                    var div = 100000000
                    var i = 0
                    while (fractionalDigits == -1 && inNano > 0 ||
                        fractionalDigits == -2 && (inNano > 0 || i % 3 != 0) ||
                        i < fractionalDigits
                    ) {
                        val digit = inNano / div
                        buf.append((digit + '0'.toInt()).toChar())
                        inNano -= digit * div
                        div /= 10
                        i += 1
                    }
                }
                buf.append('Z')
                return true
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                // new context to avoid overwriting fields like year/month/day
                val minDigits = if (fractionalDigits < 0) 0 else fractionalDigits
                val maxDigits = if (fractionalDigits < 0) 9 else fractionalDigits
                val parser = DateTimeFormatterBuilder()
                    .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')
                    .appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':')
                    .appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':')
                    .appendValue(ChronoField.SECOND_OF_MINUTE, 2)
                    .appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true)
                    .appendLiteral('Z')
                    .toFormatter().toPrinterParser(false)
                val newContext = context.copy()
                val pos = parser.parse(newContext, text, position)
                if (pos < 0) {
                    return pos
                }
                // parser restricts most fields to 2 digits, so definitely int
                // correctly parsed nano is also guaranteed to be valid
                val yearParsed = newContext.getParsed(ChronoField.YEAR)
                val month = newContext.getParsed(ChronoField.MONTH_OF_YEAR)!!.toInt()
                val day = newContext.getParsed(ChronoField.DAY_OF_MONTH)!!.toInt()
                var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY)!!.toInt()
                val min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR)!!.toInt()
                val secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE)
                val nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND)
                var sec = secVal?.toInt() ?: 0
                val nano = nanoVal?.toInt() ?: 0
                var days = 0
                if (hour == 24 && min == 0 && sec == 0 && nano == 0) {
                    hour = 0
                    days = 1
                } else if (hour == 23 && min == 59 && sec == 60) {
                    context.setParsedLeapSecond()
                    sec = 59
                }
                val year = yearParsed!!.toInt() % 10000
                var instantSecs: Long
                try {
                    val ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days)
                    instantSecs = ldt.toEpochSecond(ZoneOffset.UTC)
                    instantSecs += MathUtils.multiplyExact(yearParsed / 10_000L, SECONDS_PER_10000_YEARS)
                } catch (ex: RuntimeException) {
                    return position.inv()
                }

                var successPos = pos
                successPos = context.setParsedField(ChronoField.INSTANT_SECONDS,
                        instantSecs, position, successPos)
                return context.setParsedField(ChronoField.NANO_OF_SECOND, nano.toLong(),
                        position, successPos)
            }

            override fun toString(): String {
                return "Instant()"
            }
        } // internal class InstantPrinterParser

        /**
         * Prints or parses an offset ID.
         */
        internal class OffsetIdPrinterParser private constructor(
            private val noOffsetText: String,
            private val type: Int,
            private val style: Int
        ): DateTimePrinterParser {
            /**
             * Constructor.
             *
             * @param pattern  the pattern
             * @param noOffsetText  the text to use for UTC, not null
             */
            internal constructor(pattern: String, noOffsetText: String):
                    this(noOffsetText, checkPattern(pattern), checkPattern(pattern) % 11)

            companion object {
                internal val PATTERNS = arrayOf(
                    "+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM",
                    "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS", "+HHmmss",
                    "+HH:mm:ss", "+H", "+Hmm", "+H:mm", "+HMM",
                    "+H:MM", "+HMMss", "+H:MM:ss", "+HMMSS", "+H:MM:SS",
                    "+Hmmss", "+H:mm:ss"
                    )  // order used in pattern builder

                internal val INSTANCE_ID_Z: OffsetIdPrinterParser = OffsetIdPrinterParser("+HH:MM:ss", "Z")
                internal val INSTANCE_ID_ZERO: OffsetIdPrinterParser = OffsetIdPrinterParser("+HH:MM:ss", "0")

                private fun checkPattern(pattern: String): Int {
                    for (i in 0 until PATTERNS.size) {
                        if (PATTERNS[i] == pattern) {
                            return i
                        }
                    }
                    throw IllegalArgumentException("Invalid zone offset pattern: $pattern")
                }
            }

            private fun isPaddedHour(): Boolean {
                return type < 11
            }

            private fun isColon(): Boolean {
                return style > 0 && (style % 2) == 0
            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS) ?: return false
                val totalSecs = MathUtils.toIntExact(offsetSecs)
                if (totalSecs == 0) {
                    buf.append(noOffsetText)
                } else {
                    val absHours = (totalSecs / 3600 % 100).absoluteValue  // anything larger than 99 silently dropped
                    val absMinutes = (totalSecs / 60 % 60).absoluteValue
                    val absSeconds = (totalSecs % 60).absoluteValue
                    val bufPos = buf.length
                    var output = absHours
                    buf.append(if (totalSecs < 0) "-" else "+")
                    if (isPaddedHour() || absHours >= 10) {
                        formatZeroPad(false, absHours, buf)
                    } else {
                        buf.append((absHours + '0'.toInt()).toChar())
                    }
                    if (style in 3..8 || style >= 9 && absSeconds > 0 || style >= 1 && absMinutes > 0) {
                        formatZeroPad(isColon(), absMinutes, buf)
                        output += absMinutes
                        if (style == 7 || style == 8 || style >= 5 && absSeconds > 0) {
                            formatZeroPad(isColon(), absSeconds, buf)
                            output += absSeconds
                        }
                    }
                    if (output == 0) {
                        buf.setLength(bufPos)
                        buf.append(noOffsetText)
                    }
                }
                return true
            } // fun format

            private fun formatZeroPad(colon: Boolean, value: Int, buf: StringBuilder) {
                buf.append(if (colon) ":" else "")
                    .append((value / 10 + '0'.toInt()).toChar())
                    .append((value % 10 + '0'.toInt()).toChar())
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                val length = text.length
                val noOffsetLen = noOffsetText.length
                if (noOffsetLen == 0) {
                    if (position == length) {
                        return context.setParsedField(
                            ChronoField.OFFSET_SECONDS,
                            0, position, position
                        )
                    }
                } else {
                    if (position == length) {
                        return position.inv()
                    }
                    if (context.subSequenceEquals(text, position, noOffsetText, 0, noOffsetLen)) {
                        return context.setParsedField(
                            ChronoField.OFFSET_SECONDS, 0,
                            position, position + noOffsetLen
                        )
                    }
                }

                // parse normal plus/minus offset
                val sign = text[position]  // IOOBE if invalid position
                if (sign == '+' || sign == '-') {
                    // starts
                    val negative = if (sign == '-') -1 else 1
                    var isColon = isColon()
                    val paddedHour = isPaddedHour()
                    val array = intArrayOf(position + 1, 0, 0, 0)
                    var parseType = type
                    // select parse type when lenient
                    if (!context.strict) {
                        if (paddedHour) {
                            if (isColon || (parseType == 0 && length > position + 3 && text[position + 3] == ':')) {
                                isColon = true // needed in cases like ("+HH", "+01:01")
                                parseType = 10
                            } else {
                                parseType = 9
                            }
                        } else {
                            if (isColon || (parseType == 11 && length > position + 3 && (text[position + 2] == ':' || text[position + 3] == ':'))) {
                                isColon = true
                                parseType = 21  // needed in cases like ("+H", "+1:01")
                            } else {
                                parseType = 20
                            }
                        }
                    }
                    // parse according to the selected pattern
                    when (parseType) {
                        0, // +HH
                        11 -> // +H
                            parseHour(text, paddedHour, array)
                        1, // +HHmm
                        2, // +HH:mm
                        13 -> // +H:mm
                        {
                            parseHour(text, paddedHour, array)
                            parseMinute(text, isColon, false, array)
                        }
                        3, // +HHMM
                        4, // +HH:MM
                        15 -> // +H:MM
                        {
                            parseHour(text, paddedHour, array)
                            parseMinute(text, isColon, true, array)
                        }
                        5, // +HHMMss
                        6, // +HH:MM:ss
                        17 -> // +H:MM:ss
                        {
                            parseHour(text, paddedHour, array)
                            parseMinute(text, isColon, true, array)
                            parseSecond(text, isColon, false, array)
                        }
                        7, // +HHMMSS
                        8, // +HH:MM:SS
                        19 -> // +H:MM:SS
                        {
                            parseHour(text, paddedHour, array)
                            parseMinute(text, isColon, true, array)
                            parseSecond(text, isColon, true, array)
                        }
                        9, // +HHmmss
                        10, // +HH:mm:ss
                        21 -> // +H:mm:ss
                        {
                            parseHour(text, paddedHour, array)
                            parseOptionalMinuteSecond(text, isColon, array)
                        }
                        12 -> // +Hmm
                            parseVariableWidthDigits(text, 1, 4, array)
                        14 -> // +HMM
                            parseVariableWidthDigits(text, 3, 4, array)
                        16 -> // +HMMss
                            parseVariableWidthDigits(text, 3, 6, array)
                        18 -> // +HMMSS
                            parseVariableWidthDigits(text, 5, 6, array)
                        20 -> // +Hmmss
                            parseVariableWidthDigits(text, 1, 6, array)
                    }
                    if (array[0] > 0) {
                        if (array[1] > 23 || array[2] > 59 || array[3] > 59) {
                            throw DateTimeException("Value out of range: Hour[0-23], Minute[0-59], Second[0-59]");
                        }
                        val offsetSecs = negative * (array[1] * 3600L + array[2] * 60L + array[3])
                        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0])
                    }
                }
                // handle special case of empty no offset text
                if (noOffsetLen == 0) {
                    return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position)
                }
                return position.inv()
            } // fun parse

            private fun parseHour(parseText: CharSequence, paddedHour: Boolean, array: IntArray) {
                if (paddedHour) {
                    // parse two digits
                    if (!parseDigits(parseText, false, 1, array)) {
                        array[0] = array[0].inv()
                    }
                } else {
                    // parse one or two digits
                    parseVariableWidthDigits(parseText, 1, 2, array)
                }
            }

            private fun parseMinute(parseText: CharSequence, isColon: Boolean, mandatory: Boolean, array: IntArray) {
                if (!parseDigits(parseText, isColon, 2, array)) {
                    if (mandatory) {
                        array[0] = array[0].inv()
                    }
                }
            }

            private fun parseSecond(parseText: CharSequence, isColon: Boolean, mandatory: Boolean, array: IntArray) {
                if (!parseDigits(parseText, isColon, 3, array)) {
                    if (mandatory) {
                        array[0] = array[0].inv()
                    }
                }
            }

            private fun parseOptionalMinuteSecond(parseText: CharSequence, isColon: Boolean, array: IntArray) {
                if (parseDigits(parseText, isColon, 2, array)) {
                    parseDigits(parseText, isColon, 3, array)
                }
            }

            private fun parseDigits(
                parseText: CharSequence,
                isColon: Boolean,
                arrayIndex: Int,
                array: IntArray
            ): Boolean {
                var pos = array[0]
                if (pos < 0) {
                    return true
                }
                if (isColon && arrayIndex != 1) { //  ':' will precede only in case of minute/second
                    if (pos + 1 > parseText.length || parseText[pos] != ':') {
                        return false
                    }
                    pos++
                }
                if (pos + 2 > parseText.length) {
                    return false
                }
                val ch1 = parseText[pos++]
                val ch2 = parseText[pos++]
                if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
                    return false
                }
                val value = (ch1.toInt() - 48) * 10 + (ch2.toInt() - 48)
                if (value < 0 || value > 59) {
                    return false
                }
                array[arrayIndex] = value
                array[0] = pos
                return true
            }

            private fun parseVariableWidthDigits(
                parseText: CharSequence,
                minDigits: Int,
                maxDigits: Int,
                array: IntArray
            ) {
                // scan the text to find the available number of digits up to maxDigits
                // so long as the number available is minDigits or more, the input is valid
                // then parse the number of available digits
                var pos = array[0]
                var available = 0
                val chars = CharArray(maxDigits)
                for (i in 0 until maxDigits) {
                    if (pos + 1 > parseText.length) {
                        break
                    }
                    val ch = parseText[pos++]
                    if (ch < '0' || ch > '9') {
                        pos--
                        break
                    }
                    chars[i] = ch
                    available++
                }
                if (available < minDigits) {
                    array[0] = array[0].inv()
                    return
                }
                when (available) {
                    1 -> array[1] = chars[0].toInt() - 48
                    2 -> array[1] = (chars[0].toInt() - 48) * 10 + (chars[1].toInt() - 48)
                    3 -> {
                        array[1] = chars[0].toInt() - 48
                        array[2] = (chars[1].toInt() - 48) * 10 + (chars[2].toInt() - 48)
                    }
                    4 -> {
                        array[1] = (chars[0].toInt() - 48) * 10 + (chars[1].toInt() - 48)
                        array[2] = (chars[2].toInt() - 48) * 10 + (chars[3].toInt() - 48)
                    }
                    5 -> {
                        array[1] = chars[0].toInt() - 48
                        array[2] = (chars[1].toInt() - 48) * 10 + (chars[2].toInt() - 48)
                        array[3] = (chars[3].toInt() - 48) * 10 + (chars[4].toInt() - 48)
                    }
                    6 -> {
                        array[1] = (chars[0].toInt() - 48) * 10 + (chars[1].toInt() - 48)
                        array[2] = (chars[2].toInt() - 48) * 10 + (chars[3].toInt() - 48)
                        array[3] = (chars[4].toInt() - 48) * 10 + (chars[5].toInt() - 48)
                    }
                }
                array[0] = pos
            }

            override fun toString(): String {
                val converted = noOffsetText.replace("'", "''")
                return "Offset(" + PATTERNS[type] + ",'" + converted + "')"
            }
        } // internal class OffsetIdPrinterParser

        /**
         * Prints or parses an offset ID.
         */
        internal class LocalizedOffsetIdPrinterParser internal constructor(
            private val style: TextStyle
        ): DateTimePrinterParser {

            companion object {
                private fun appendHMS(buf: StringBuilder, t: Int): StringBuilder {
                    return buf.append((t / 10 + '0'.toInt()).toChar())
                        .append((t % 10 + '0'.toInt()).toChar())
                }
            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS) ?: return false
                val gmtText = "GMT"  // TODO: get localized version of 'GMT'
                buf.append(gmtText)
                val totalSecs = MathUtils.toIntExact(offsetSecs)
                if (totalSecs != 0) {
                    val absHours = (totalSecs / 3600 % 100).absoluteValue  // anything larger than 99 silently dropped
                    val absMinutes = (totalSecs / 60 % 60).absoluteValue
                    val absSeconds = (totalSecs % 60).absoluteValue
                    buf.append(if (totalSecs < 0) "-" else "+")
                    if (style == TextStyle.FULL) {
                        appendHMS(buf, absHours)
                        buf.append(':')
                        appendHMS(buf, absMinutes)
                        if (absSeconds != 0) {
                            buf.append(':')
                            appendHMS(buf, absSeconds)
                        }
                    } else {
                        if (absHours >= 10) {
                            buf.append((absHours / 10 + '0'.toInt()).toChar())
                        }
                        buf.append((absHours % 10 + '0'.toInt()).toChar())
                        if (absMinutes != 0 || absSeconds != 0) {
                            buf.append(':')
                            appendHMS(buf, absMinutes)
                            if (absSeconds != 0) {
                                buf.append(':')
                                appendHMS(buf, absSeconds)
                            }
                        }
                    }
                }
                return true
            } // fun format

            internal fun getDigit(text: CharSequence, position: Int): Int {
                val c = text[position]
                return if (c < '0' || c > '9') {
                    -1
                } else c - '0'
            }

            override fun parse(context: DateTimeParseContext, text: CharSequence, position: Int): Int {
                var pos = position
                val end = text.length
                val gmtText = "GMT"  // TODO: get localized version of 'GMT'
                if (!context.subSequenceEquals(text, pos, gmtText, 0, gmtText.length)) {
                    return position.inv()
                }
                pos += gmtText.length
                // parse normal plus/minus offset
                var negative = 0
                if (pos == end) {
                    return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, pos)
                }
                val sign = text[pos]  // IOOBE if invalid position
                if (sign == '+') {
                    negative = 1
                } else if (sign == '-') {
                    negative = -1
                } else {
                    return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, pos)
                }
                pos += 1
                var h: Int
                var m = 0
                var s = 0
                if (style === TextStyle.FULL) {
                    val h1 = getDigit(text, pos++)
                    val h2 = getDigit(text, pos++)
                    if (h1 < 0 || h2 < 0 || text[pos++] != ':') {
                        return position.inv()
                    }
                    h = h1 * 10 + h2
                    val m1 = getDigit(text, pos++)
                    val m2 = getDigit(text, pos++)
                    if (m1 < 0 || m2 < 0) {
                        return position.inv()
                    }
                    m = m1 * 10 + m2
                    if (pos + 2 < end && text[pos] == ':') {
                        val s1 = getDigit(text, pos + 1)
                        val s2 = getDigit(text, pos + 2)
                        if (s1 >= 0 && s2 >= 0) {
                            s = s1 * 10 + s2
                            pos += 3
                        }
                    }
                } else {
                    h = getDigit(text, pos++)
                    if (h < 0) {
                        return position.inv()
                    }
                    if (pos < end) {
                        val h2 = getDigit(text, pos)
                        if (h2 >= 0) {
                            h = h * 10 + h2
                            pos++
                        }
                        if (pos + 2 < end && text[pos] == ':') {
                            if (pos + 2 < end && text[pos] == ':') {
                                val m1 = getDigit(text, pos + 1)
                                val m2 = getDigit(text, pos + 2)
                                if (m1 >= 0 && m2 >= 0) {
                                    m = m1 * 10 + m2
                                    pos += 3
                                    if (pos + 2 < end && text[pos] == ':') {
                                        val s1 = getDigit(text, pos + 1)
                                        val s2 = getDigit(text, pos + 2)
                                        if (s1 >= 0 && s2 >= 0) {
                                            s = s1 * 10 + s2
                                            pos += 3
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                val offsetSecs = negative * (h * 3600L + m * 60L + s.toLong())
                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, pos)
            } // fun parse

            override fun toString(): String {
                return "LocalizedOffset($style)"
            }
        } // internal class LocalizedOffsetIdPrinterParser

        /**
         * Prints or parses a zone ID.
         */
        internal class ZoneTextPrinterParser internal constructor(
            /** The text style to output. */
            private val textStyle: TextStyle,

            /** The preferred zoneid map */
            preferredZones: Set<String>,

            /**  Display in generic time-zone format. True in case of pattern letter 'v' */
            private val isGeneric: Boolean
        ): ZoneIdPrinterParser(TemporalQueries.ZONE, "ZoneText($textStyle)") {
            private val preferredZones: Set<String> =
                if (null == preferredZones) HashSet() else HashSet(preferredZones)

            companion object {
                private const val STD = 0
                private const val DST = 1
                private const val GENERIC = 2
            }

            private fun getDisplayName(id: String, type: Int /*, locale: Locale */): String {
                if (textStyle == TextStyle.NARROW) {
                    return null
                }
                var names: Array<String>

            }

            override fun format(context: DateTimePrintContext, buf: StringBuilder): Boolean {
                val zone: ZoneId? = context.getValue(TemporalQueries.ZONE_ID)
                if (zone == null) {
                    return false
                }
                var zname: String = zone.getId()
                if (zone !is ZoneOffset) {
                    val dt: TemporalAccessor = context.temporal
                    var type = GENERIC
                    if (!isGeneric) {
                        if (dt.isSupported(ChronoField.INSTANT_SECONDS)) {
                            type = if (zone.getRules()!!.isDaylightSavings(Instant.from(dt))) DST else STD
                        } else if (dt.isSupported(ChronoField.EPOCH_DAY) &&
                            dt.isSupported(ChronoField.NANO_OF_DAY)
                        ) {
                            val date: LocalDate = LocalDate.ofEpochDay(dt.getLong(ChronoField.EPOCH_DAY))
                            val time: LocalTime = LocalTime.ofNanoOfDay(dt.getLong(ChronoField.NANO_OF_DAY))
                            val ldt: LocalDateTime = date.atTime(time)
                            if (zone.getRules()!!.getTransition(ldt) == null) {
                                type = if (zone.getRules()!!.isDaylightSavings(ldt.atZone(zone).toInstant()))
                                    DST else STD
                            }
                        }
                    }
                    val name: String = getDisplayName(zname, type, context.getLocale())
                    if (name != null) {
                        zname = name
                    }
                }
                buf.append(zname)
                return true
            }
        } // internal class ZoneTextPrinterParser
    } // companion object

    //-----------------------------------------------------------------------
    /**
     * Changes the parse style to be case sensitive for the remainder of the formatter.
     *
     *
     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
     * This method allows the case sensitivity setting of parsing to be changed.
     *
     *
     * Calling this method changes the state of the builder such that all
     * subsequent builder method calls will parse text in case sensitive mode.
     * See [.parseCaseInsensitive] for the opposite setting.
     * The parse case sensitive/insensitive methods may be called at any point
     * in the builder, thus the parser can swap between case parsing modes
     * multiple times during the parse.
     *
     *
     * Since the default is case sensitive, this method should only be used after
     * a previous call to `#parseCaseInsensitive`.
     *
     * @return this, for chaining, not null
     */
    fun parseCaseSensitive(): DateTimeFormatterBuilder {
        appendInternal(SettingsParser.SENSITIVE)
        return this
    }

    /**
     * Changes the parse style to be case insensitive for the remainder of the formatter.
     *
     *
     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
     * This method allows the case sensitivity setting of parsing to be changed.
     *
     *
     * Calling this method changes the state of the builder such that all
     * subsequent builder method calls will parse text in case insensitive mode.
     * See [.parseCaseSensitive] for the opposite setting.
     * The parse case sensitive/insensitive methods may be called at any point
     * in the builder, thus the parser can swap between case parsing modes
     * multiple times during the parse.
     *
     * @return this, for chaining, not null
     */
    fun parseCaseInsensitive(): DateTimeFormatterBuilder {
        appendInternal(SettingsParser.INSENSITIVE)
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Changes the parse style to be strict for the remainder of the formatter.
     *
     *
     * Parsing can be strict or lenient - by default its strict.
     * This controls the degree of flexibility in matching the text and sign styles.
     *
     *
     * When used, this method changes the parsing to be strict from this point onwards.
     * As strict is the default, this is normally only needed after calling [.parseLenient].
     * The change will remain in force until the end of the formatter that is eventually
     * constructed or until `parseLenient` is called.
     *
     * @return this, for chaining, not null
     */
    fun parseStrict(): DateTimeFormatterBuilder {
        appendInternal(SettingsParser.STRICT)
        return this
    }

    /**
     * Changes the parse style to be lenient for the remainder of the formatter.
     * Note that case sensitivity is set separately to this method.
     *
     *
     * Parsing can be strict or lenient - by default its strict.
     * This controls the degree of flexibility in matching the text and sign styles.
     * Applications calling this method should typically also call [.parseCaseInsensitive].
     *
     *
     * When used, this method changes the parsing to be lenient from this point onwards.
     * The change will remain in force until the end of the formatter that is eventually
     * constructed or until `parseStrict` is called.
     *
     * @return this, for chaining, not null
     */
    fun parseLenient(): DateTimeFormatterBuilder {
        appendInternal(SettingsParser.LENIENT)
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Appends a default value for a field to the formatter for use in parsing.
     *
     *
     * This appends an instruction to the builder to inject a default value
     * into the parsed result. This is especially useful in conjunction with
     * optional parts of the formatter.
     *
     *
     * For example, consider a formatter that parses the year, followed by
     * an optional month, with a further optional day-of-month. Using such a
     * formatter would require the calling code to check whether a full date,
     * year-month or just a year had been parsed. This method can be used to
     * default the month and day-of-month to a sensible value, such as the
     * first of the month, allowing the calling code to always get a date.
     *
     *
     * During formatting, this method has no effect.
     *
     *
     * During parsing, the current state of the parse is inspected.
     * If the specified field has no associated value, because it has not been
     * parsed successfully at that point, then the specified value is injected
     * into the parse result. Injection is immediate, thus the field-value pair
     * will be visible to any subsequent elements in the formatter.
     * As such, this method is normally called at the end of the builder.
     *
     * @param field  the field to default the value of, not null
     * @param value  the value to default the field to
     * @return this, for chaining, not null
     */
    fun parseDefaulting(field: TemporalField, value: Long): DateTimeFormatterBuilder {
        appendInternal(DefaultValueParser(field, value))
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Causes the next added printer/parser to pad to a fixed width using a space.
     *
     *
     * This padding will pad to a fixed width using spaces.
     *
     *
     * During formatting, the decorated element will be output and then padded
     * to the specified width. An exception will be thrown during formatting if
     * the pad width is exceeded.
     *
     *
     * During parsing, the padding and decorated element are parsed.
     * If parsing is lenient, then the pad width is treated as a maximum.
     * The padding is parsed greedily. Thus, if the decorated element starts with
     * the pad character, it will not be parsed.
     *
     * @param padWidth  the pad width, 1 or greater
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if pad width is too small
     */
    fun padNext(padWidth: Int): DateTimeFormatterBuilder {
        return padNext(padWidth, ' ')
    }

    /**
     * Causes the next added printer/parser to pad to a fixed width.
     *
     *
     * This padding is intended for padding other than zero-padding.
     * Zero-padding should be achieved using the appendValue methods.
     *
     *
     * During formatting, the decorated element will be output and then padded
     * to the specified width. An exception will be thrown during formatting if
     * the pad width is exceeded.
     *
     *
     * During parsing, the padding and decorated element are parsed.
     * If parsing is lenient, then the pad width is treated as a maximum.
     * If parsing is case insensitive, then the pad character is matched ignoring case.
     * The padding is parsed greedily. Thus, if the decorated element starts with
     * the pad character, it will not be parsed.
     *
     * @param padWidth  the pad width, 1 or greater
     * @param padChar  the pad character
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if pad width is too small
     */
    fun padNext(padWidth: Int, padChar: Char): DateTimeFormatterBuilder {
        if (padWidth < 1) {
            throw IllegalArgumentException("The pad width must be at least one but was $padWidth")
        }
        active.padNextWidth = padWidth
        active.padNextChar = padChar
        active.valueParserIndex = -1
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the value of a date-time field to the formatter using a normal
     * output style.
     *
     *
     * The value of the field will be output during a format.
     * If the value cannot be obtained then an exception will be thrown.
     *
     *
     * The value will be printed as per the normal format of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     *
     *
     * The parser for a variable width value such as this normally behaves greedily,
     * requiring one digit, but accepting as many digits as possible.
     * This behavior can be affected by 'adjacent value parsing'.
     * See [.appendValue] for full details.
     *
     * @param field  the field to append, not null
     * @return this, for chaining, not null
     */
    fun appendValue(field: TemporalField): DateTimeFormatterBuilder {
        appendValue(NumberPrinterParser(field, 1, 19, SignStyle.NORMAL))
        return this
    }

    /**
     * Appends the value of a date-time field to the formatter using a fixed
     * width, zero-padded approach.
     *
     *
     * The value of the field will be output during a format.
     * If the value cannot be obtained then an exception will be thrown.
     *
     *
     * The value will be zero-padded on the left. If the size of the value
     * means that it cannot be printed within the width then an exception is thrown.
     * If the value of the field is negative then an exception is thrown during formatting.
     *
     *
     * This method supports a special technique of parsing known as 'adjacent value parsing'.
     * This technique solves the problem where a value, variable or fixed width, is followed by one or more
     * fixed length values. The standard parser is greedy, and thus it would normally
     * steal the digits that are needed by the fixed width value parsers that follow the
     * variable width one.
     *
     *
     * No action is required to initiate 'adjacent value parsing'.
     * When a call to `appendValue` is made, the builder
     * enters adjacent value parsing setup mode. If the immediately subsequent method
     * call or calls on the same builder are for a fixed width value, then the parser will reserve
     * space so that the fixed width values can be parsed.
     *
     *
     * For example, consider `builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);`
     * The year is a variable width parse of between 1 and 19 digits.
     * The month is a fixed width parse of 2 digits.
     * Because these were appended to the same builder immediately after one another,
     * the year parser will reserve two digits for the month to parse.
     * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.
     * Without adjacent value parsing, the year would greedily parse all six digits and leave
     * nothing for the month.
     *
     *
     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser
     * that immediately follow any kind of value, variable or fixed width.
     * Calling any other append method will end the setup of adjacent value parsing.
     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
     * simply add the `appendValue` to another `DateTimeFormatterBuilder`
     * and add that to this builder.
     *
     *
     * If adjacent parsing is active, then parsing must match exactly the specified
     * number of digits in both strict and lenient modes.
     * In addition, no positive or negative sign is permitted.
     *
     * @param field  the field to append, not null
     * @param width  the width of the printed field, from 1 to 19
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width is invalid
     */
    fun appendValue(field: TemporalField, width: Int): DateTimeFormatterBuilder {
        if (width < 1 || width > 19) {
            throw IllegalArgumentException("The width must be from 1 to 19 inclusive but was $width")
        }
        val pp = NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE)
        appendValue(pp)
        return this
    }

    /**
     * Appends the value of a date-time field to the formatter providing full
     * control over formatting.
     *
     *
     * The value of the field will be output during a format.
     * If the value cannot be obtained then an exception will be thrown.
     *
     *
     * This method provides full control of the numeric formatting, including
     * zero-padding and the positive/negative sign.
     *
     *
     * The parser for a variable width value such as this normally behaves greedily,
     * accepting as many digits as possible.
     * This behavior can be affected by 'adjacent value parsing'.
     * See [.appendValue] for full details.
     *
     *
     * In strict parsing mode, the minimum number of parsed digits is `minWidth`
     * and the maximum is `maxWidth`.
     * In lenient parsing mode, the minimum number of parsed digits is one
     * and the maximum is 19 (except as limited by adjacent value parsing).
     *
     *
     * If this method is invoked with equal minimum and maximum widths and a sign style of
     * `NOT_NEGATIVE` then it delegates to `appendValue(TemporalField,int)`.
     * In this scenario, the formatting and parsing behavior described there occur.
     *
     * @param field  the field to append, not null
     * @param minWidth  the minimum field width of the printed field, from 1 to 19
     * @param maxWidth  the maximum field width of the printed field, from 1 to 19
     * @param signStyle  the positive/negative output style, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the widths are invalid
     */
    fun appendValue(
        field: TemporalField, minWidth: Int, maxWidth: Int, signStyle: SignStyle
    ): DateTimeFormatterBuilder {
        if (minWidth == maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
            return appendValue(field, maxWidth)
        }
        if (minWidth < 1 || minWidth > 19) {
            throw IllegalArgumentException("The minimum width must be from 1 to 19 inclusive but was $minWidth")
        }
        if (maxWidth < 1 || maxWidth > 19) {
            throw IllegalArgumentException("The maximum width must be from 1 to 19 inclusive but was $maxWidth")
        }
        if (maxWidth < minWidth) {
            throw IllegalArgumentException(
                "The maximum width must exceed or equal the minimum width but " +
                        maxWidth + " < " + minWidth
            )
        }
        val pp = NumberPrinterParser(field, minWidth, maxWidth, signStyle)
        appendValue(pp)
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the reduced value of a date-time field to the formatter.
     *
     *
     * Since fields such as year vary by chronology, it is recommended to use the
     * [.appendValueReduced] date}
     * variant of this method in most cases. This variant is suitable for
     * simple fields or working with only the ISO chronology.
     *
     *
     * For formatting, the `width` and `maxWidth` are used to
     * determine the number of characters to format.
     * If they are equal then the format is fixed width.
     * If the value of the field is within the range of the `baseValue` using
     * `width` characters then the reduced value is formatted otherwise the value is
     * truncated to fit `maxWidth`.
     * The rightmost characters are output to match the width, left padding with zero.
     *
     *
     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.
     * For lenient parsing, the number of characters must be at least 1 and less than 10.
     * If the number of digits parsed is equal to `width` and the value is positive,
     * the value of the field is computed to be the first number greater than
     * or equal to the `baseValue` with the same least significant characters,
     * otherwise the value parsed is the field value.
     * This allows a reduced value to be entered for values in range of the baseValue
     * and width and absolute values can be entered for values outside the range.
     *
     *
     * For example, a base value of `1980` and a width of `2` will have
     * valid values from `1980` to `2079`.
     * During parsing, the text `"12"` will result in the value `2012` as that
     * is the value within the range where the last two characters are "12".
     * By contrast, parsing the text `"1915"` will result in the value `1915`.
     *
     * @param field  the field to append, not null
     * @param width  the field width of the printed and parsed field, from 1 to 10
     * @param maxWidth  the maximum field width of the printed field, from 1 to 10
     * @param baseValue  the base value of the range of valid values
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width or base value is invalid
     */
    fun appendValueReduced(
        field: TemporalField,
        width: Int, maxWidth: Int, baseValue: Int
    ): DateTimeFormatterBuilder {
        val pp = ReducedPrinterParser(field, width, maxWidth, baseValue, null)
        appendValue(pp)
        return this
    }

    /**
     * Appends the reduced value of a date-time field to the formatter.
     *
     *
     * This is typically used for formatting and parsing a two digit year.
     *
     *
     * The base date is used to calculate the full value during parsing.
     * For example, if the base date is 1950-01-01 then parsed values for
     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
     * Only the year would be extracted from the date, thus a base date of
     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
     * This behavior is necessary to support fields such as week-based-year
     * or other calendar systems where the parsed value does not align with
     * standard ISO years.
     *
     *
     * The exact behavior is as follows. Parse the full set of fields and
     * determine the effective chronology using the last chronology if
     * it appears more than once. Then convert the base date to the
     * effective chronology. Then extract the specified field from the
     * chronology-specific base date and use it to determine the
     * `baseValue` used below.
     *
     *
     * For formatting, the `width` and `maxWidth` are used to
     * determine the number of characters to format.
     * If they are equal then the format is fixed width.
     * If the value of the field is within the range of the `baseValue` using
     * `width` characters then the reduced value is formatted otherwise the value is
     * truncated to fit `maxWidth`.
     * The rightmost characters are output to match the width, left padding with zero.
     *
     *
     * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.
     * For lenient parsing, the number of characters must be at least 1 and less than 10.
     * If the number of digits parsed is equal to `width` and the value is positive,
     * the value of the field is computed to be the first number greater than
     * or equal to the `baseValue` with the same least significant characters,
     * otherwise the value parsed is the field value.
     * This allows a reduced value to be entered for values in range of the baseValue
     * and width and absolute values can be entered for values outside the range.
     *
     *
     * For example, a base value of `1980` and a width of `2` will have
     * valid values from `1980` to `2079`.
     * During parsing, the text `"12"` will result in the value `2012` as that
     * is the value within the range where the last two characters are "12".
     * By contrast, parsing the text `"1915"` will result in the value `1915`.
     *
     * @param field  the field to append, not null
     * @param width  the field width of the printed and parsed field, from 1 to 10
     * @param maxWidth  the maximum field width of the printed field, from 1 to 10
     * @param baseDate  the base date used to calculate the base value for the range
     * of valid values in the parsed chronology, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width or base value is invalid
     */
    fun appendValueReduced(
        field: TemporalField, width: Int, maxWidth: Int, baseDate: ChronoLocalDate
    ): DateTimeFormatterBuilder {
        val pp = ReducedPrinterParser(field, width, maxWidth, 0, baseDate)
        appendValue(pp)
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the text of a date-time field to the formatter using the full
     * text style.
     *
     *
     * The text of the field will be output during a format.
     * The value must be within the valid range of the field.
     * If the value cannot be obtained then an exception will be thrown.
     * If the field has no textual representation, then the numeric value will be used.
     *
     *
     * The value will be printed as per the normal format of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     *
     * @param field  the field to append, not null
     * @return this, for chaining, not null
     */
    fun appendText(field: TemporalField): DateTimeFormatterBuilder {
        return appendText(field, TextStyle.FULL)
    }

    /**
     * Appends the text of a date-time field to the formatter.
     *
     *
     * The text of the field will be output during a format.
     * The value must be within the valid range of the field.
     * If the value cannot be obtained then an exception will be thrown.
     * If the field has no textual representation, then the numeric value will be used.
     *
     *
     * The value will be printed as per the normal format of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     *
     * @param field  the field to append, not null
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     */
    fun appendText(field: TemporalField, textStyle: TextStyle): DateTimeFormatterBuilder {
        appendInternal(TextPrinterParser(field, textStyle, DateTimeTextProvider.getInstance()))
        return this
    }

    /**
     * Appends the text of a date-time field to the formatter using the specified
     * map to supply the text.
     *
     *
     * The standard text outputting methods use the localized text in the JDK.
     * This method allows that text to be specified directly.
     * The supplied map is not validated by the builder to ensure that formatting or
     * parsing is possible, thus an invalid map may throw an error during later use.
     *
     *
     * Supplying the map of text provides considerable flexibility in formatting and parsing.
     * For example, a legacy application might require or supply the months of the
     * year as "JNY", "FBY", "MCH" etc. These do not match the standard set of text
     * for localized month names. Using this method, a map can be created which
     * defines the connection between each value and the text:
     * <pre>
     * Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();
     * map.put(1L, "JNY");
     * map.put(2L, "FBY");
     * map.put(3L, "MCH");
     * ...
     * builder.appendText(MONTH_OF_YEAR, map);
     * </pre>
     *
     *
     * Other uses might be to output the value with a suffix, such as "1st", "2nd", "3rd",
     * or as Roman numerals "I", "II", "III", "IV".
     *
     *
     * During formatting, the value is obtained and checked that it is in the valid range.
     * If text is not available for the value then it is output as a number.
     * During parsing, the parser will match against the map of text and numeric values.
     *
     * @param field  the field to append, not null
     * @param textLookup  the map from the value to the text
     * @return this, for chaining, not null
    fun appendText(field: TemporalField, textLookup: Map<Long, String>): DateTimeFormatterBuilder {
        val copy = LinkedHashMap(textLookup)
        val map = Collections.singletonMap(TextStyle.FULL, copy)
        val store = LocaleStore(map)
        val provider = object : DateTimeTextProvider() {
            fun getText(
                chrono: Chronology, field: TemporalField,
                value: Long, style: TextStyle, locale: Locale
            ): String {
                return store.getText(value, style)
            }

            fun getText(field: TemporalField, value: Long, style: TextStyle, locale: Locale): String {
                return store.getText(value, style)
            }

            fun getTextIterator(field: TemporalField, style: TextStyle, locale: Locale): Iterator<Entry<String, Long>> {
                return store.getTextIterator(style)
            }
        }
        appendInternal(TextPrinterParser(field, TextStyle.FULL, provider))
        return this
    }
     */

    //-----------------------------------------------------------------------
    /**
     * Appends an instant using ISO-8601 to the formatter, formatting fractional
     * digits in groups of three.
     *
     *
     * Instants have a fixed output format.
     * They are converted to a date-time with a zone-offset of UTC and formatted
     * using the standard ISO-8601 format.
     * With this method, formatting nano-of-second outputs zero, three, six
     * or nine digits as necessary.
     * The localized decimal style is not used.
     *
     *
     * The instant is obtained using [INSTANT_SECONDS][ChronoField.INSTANT_SECONDS]
     * and optionally `NANO_OF_SECOND`. The value of `INSTANT_SECONDS`
     * may be outside the maximum range of `LocalDateTime`.
     *
     *
     * The [resolver style][ResolverStyle] has no effect on instant parsing.
     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.
     * The leap-second time of '23:59:59' is handled to some degree, see
     * [DateTimeFormatter.parsedLeapSecond] for full details.
     *
     *
     * An alternative to this method is to format/parse the instant as a single
     * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.
     *
     * @return this, for chaining, not null
     */
    fun appendInstant(): DateTimeFormatterBuilder {
        appendInternal(InstantPrinterParser(-2))
        return this
    }

    /**
     * Appends an instant using ISO-8601 to the formatter with control over
     * the number of fractional digits.
     *
     *
     * Instants have a fixed output format, although this method provides some
     * control over the fractional digits. They are converted to a date-time
     * with a zone-offset of UTC and printed using the standard ISO-8601 format.
     * The localized decimal style is not used.
     *
     *
     * The `fractionalDigits` parameter allows the output of the fractional
     * second to be controlled. Specifying zero will cause no fractional digits
     * to be output. From 1 to 9 will output an increasing number of digits, using
     * zero right-padding if necessary. The special value -1 is used to output as
     * many digits as necessary to avoid any trailing zeroes.
     *
     *
     * When parsing in strict mode, the number of parsed digits must match the
     * fractional digits. When parsing in lenient mode, any number of fractional
     * digits from zero to nine are accepted.
     *
     *
     * The instant is obtained using [INSTANT_SECONDS][ChronoField.INSTANT_SECONDS]
     * and optionally `NANO_OF_SECOND`. The value of `INSTANT_SECONDS`
     * may be outside the maximum range of `LocalDateTime`.
     *
     *
     * The [resolver style][ResolverStyle] has no effect on instant parsing.
     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.
     * The leap-second time of '23:59:60' is handled to some degree, see
     * [DateTimeFormatter.parsedLeapSecond] for full details.
     *
     *
     * An alternative to this method is to format/parse the instant as a single
     * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.
     *
     * @param fractionalDigits  the number of fractional second digits to format with,
     * from 0 to 9, or -1 to use as many digits as necessary
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the number of fractional digits is invalid
     */
    fun appendInstant(fractionalDigits: Int): DateTimeFormatterBuilder {
        if (fractionalDigits < -1 || fractionalDigits > 9) {
            throw IllegalArgumentException("The fractional digits must be from -1 to 9 inclusive but was $fractionalDigits")
        }
        appendInternal(InstantPrinterParser(fractionalDigits))
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the zone offset, such as '+01:00', to the formatter.
     *
     *
     * This appends an instruction to format/parse the offset ID to the builder.
     * This is equivalent to calling `appendOffset("+HH:mm:ss", "Z")`.
     * See [.appendOffset] for details on formatting
     * and parsing.
     *
     * @return this, for chaining, not null
     */
    fun appendOffsetId(): DateTimeFormatterBuilder {
        appendInternal(OffsetIdPrinterParser.INSTANCE_ID_Z)
        return this
    }

    /**
     * Appends the time-zone name, such as 'British Summer Time', to the formatter.
     *
     *
     * This appends an instruction to format/parse the textual name of the zone to
     * the builder.
     *
     *
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with [TemporalQueries.zoneId].
     * If the zone is a `ZoneOffset` it will be printed using the
     * result of [ZoneOffset.getId].
     * If the zone is not an offset, the textual name will be looked up
     * for the locale set in the [DateTimeFormatter].
     * If the temporal object being printed represents an instant, or if it is a
     * local date-time that is not in a daylight saving gap or overlap then
     * the text will be the summer or winter time text as appropriate.
     * If the lookup for text does not find any suitable result, then the
     * [ID][ZoneId.getId] will be printed.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     *
     *
     * During parsing, either the textual zone name, the zone ID or the offset
     * is accepted. Many textual zone names are not unique, such as CST can be
     * for both "Central Standard Time" and "China Standard Time". In this
     * situation, the zone id will be determined by the region information from
     * formatter's  [locale][DateTimeFormatter.getLocale] and the standard
     * zone id for that area, for example, America/New_York for the America Eastern
     * zone. The [.appendZoneText] may be used
     * to specify a set of preferred [ZoneId] in this situation.
     *
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     */
    fun appendZoneText(textStyle: TextStyle): DateTimeFormatterBuilder {
        appendInternal(ZoneTextPrinterParser(textStyle, null, false))
        return this
    }

    /**
     * Appends the time-zone name, such as 'British Summer Time', to the formatter.
     *
     *
     * This appends an instruction to format/parse the textual name of the zone to
     * the builder.
     *
     *
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with [TemporalQueries.zoneId].
     * If the zone is a `ZoneOffset` it will be printed using the
     * result of [ZoneOffset.getId].
     * If the zone is not an offset, the textual name will be looked up
     * for the locale set in the [DateTimeFormatter].
     * If the temporal object being printed represents an instant, or if it is a
     * local date-time that is not in a daylight saving gap or overlap, then the text
     * will be the summer or winter time text as appropriate.
     * If the lookup for text does not find any suitable result, then the
     * [ID][ZoneId.getId] will be printed.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     *
     *
     * During parsing, either the textual zone name, the zone ID or the offset
     * is accepted. Many textual zone names are not unique, such as CST can be
     * for both "Central Standard Time" and "China Standard Time". In this
     * situation, the zone id will be determined by the region information from
     * formatter's  [locale][DateTimeFormatter.getLocale] and the standard
     * zone id for that area, for example, America/New_York for the America Eastern
     * zone. This method also allows a set of preferred [ZoneId] to be
     * specified for parsing. The matched preferred zone id will be used if the
     * textural zone name being parsed is not unique.
     *
     *
     * If the zone cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     *
     * @param textStyle  the text style to use, not null
     * @param preferredZones  the set of preferred zone ids, not null
     * @return this, for chaining, not null
     */
    fun appendZoneText(
        textStyle: TextStyle,
        preferredZones: Set<ZoneId>
    ): DateTimeFormatterBuilder {
        appendInternal(ZoneTextPrinterParser(textStyle, preferredZones, false))
        return this
    }
    //----------------------------------------------------------------------
    /**
     * Appends the generic time-zone name, such as 'Pacific Time', to the formatter.
     *
     *
     * This appends an instruction to format/parse the generic textual
     * name of the zone to the builder. The generic name is the same throughout the whole
     * year, ignoring any daylight saving changes. For example, 'Pacific Time' is the
     * generic name, whereas 'Pacific Standard Time' and 'Pacific Daylight Time' are the
     * specific names, see [.appendZoneText].
     *
     *
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with [TemporalQueries.zoneId].
     * If the zone is a `ZoneOffset` it will be printed using the
     * result of [ZoneOffset.getId].
     * If the zone is not an offset, the textual name will be looked up
     * for the locale set in the [DateTimeFormatter].
     * If the lookup for text does not find any suitable result, then the
     * [ID][ZoneId.getId] will be printed.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     *
     *
     * During parsing, either the textual zone name, the zone ID or the offset
     * is accepted. Many textual zone names are not unique, such as CST can be
     * for both "Central Standard Time" and "China Standard Time". In this
     * situation, the zone id will be determined by the region information from
     * formatter's  [locale][DateTimeFormatter.getLocale] and the standard
     * zone id for that area, for example, America/New_York for the America Eastern zone.
     * The [.appendGenericZoneText] may be used
     * to specify a set of preferred [ZoneId] in this situation.
     *
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     * @since 9
     */
    fun appendGenericZoneText(textStyle: TextStyle): DateTimeFormatterBuilder {
        appendInternal(ZoneTextPrinterParser(textStyle, null, true))
        return this
    }

    /**
     * Appends the generic time-zone name, such as 'Pacific Time', to the formatter.
     *
     *
     * This appends an instruction to format/parse the generic textual
     * name of the zone to the builder. The generic name is the same throughout the whole
     * year, ignoring any daylight saving changes. For example, 'Pacific Time' is the
     * generic name, whereas 'Pacific Standard Time' and 'Pacific Daylight Time' are the
     * specific names, see [.appendZoneText].
     *
     *
     * This method also allows a set of preferred [ZoneId] to be
     * specified for parsing. The matched preferred zone id will be used if the
     * textural zone name being parsed is not unique.
     *
     *
     * See [.appendGenericZoneText] for details about
     * formatting and parsing.
     *
     * @param textStyle  the text style to use, not null
     * @param preferredZones  the set of preferred zone ids, not null
     * @return this, for chaining, not null
     * @since 9
     */
    fun appendGenericZoneText(
        textStyle: TextStyle,
        preferredZones: Set<ZoneId>
    ): DateTimeFormatterBuilder {
        appendInternal(ZoneTextPrinterParser(textStyle, preferredZones, true))
        return this
    }

    /**
     * Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.
     *
     *
     * This appends an instruction to format/parse the chronology ID to the builder.
     *
     *
     * During formatting, the chronology is obtained using a mechanism equivalent
     * to querying the temporal with [TemporalQueries.chronology].
     * It will be printed using the result of [Chronology.getId].
     * If the chronology cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     *
     *
     * During parsing, the chronology is parsed and must match one of the chronologies
     * in [Chronology.getAvailableChronologies].
     * If the chronology cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     * The parser uses the [case sensitive][.parseCaseInsensitive] setting.
     *
     * @return this, for chaining, not null
     */
    fun appendChronologyId(): DateTimeFormatterBuilder {
        appendInternal(ChronoPrinterParser(null))
        return this
    }

    /**
     * Appends the chronology name to the formatter.
     *
     *
     * The calendar system name will be output during a format.
     * If the chronology cannot be obtained then an exception will be thrown.
     *
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     */
    fun appendChronologyText(textStyle: TextStyle): DateTimeFormatterBuilder {
        appendInternal(ChronoPrinterParser(textStyle))
        return this
    }

    /**
     * Appends the elements defined by the specified pattern to the builder.
     *
     *
     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.
     * The characters '#', '{' and '}' are reserved for future use.
     * The characters '[' and ']' indicate optional patterns.
     * The following pattern letters are defined:
     * <pre>
     * Symbol  Meaning                     Presentation      Examples
     * ------  -------                     ------------      -------
     * G       era                         text              AD; Anno Domini; A
     * u       year                        year              2004; 04
     * y       year-of-era                 year              2004; 04
     * D       day-of-year                 number            189
     * M/L     month-of-year               number/text       7; 07; Jul; July; J
     * d       day-of-month                number            10
     * g       modified-julian-day         number            2451334
     *
     * Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
     * Y       week-based-year             year              1996; 96
     * w       week-of-week-based-year     number            27
     * W       week-of-month               number            4
     * E       day-of-week                 text              Tue; Tuesday; T
     * e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
     * F       day-of-week-in-month        number            3
     *
     * a       am-pm-of-day                text              PM
     * h       clock-hour-of-am-pm (1-12)  number            12
     * K       hour-of-am-pm (0-11)        number            0
     * k       clock-hour-of-day (1-24)    number            24
     *
     * H       hour-of-day (0-23)          number            0
     * m       minute-of-hour              number            30
     * s       second-of-minute            number            55
     * S       fraction-of-second          fraction          978
     * A       milli-of-day                number            1234
     * n       nano-of-second              number            987654321
     * N       nano-of-day                 number            1234000000
     *
     * V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
     * v       generic time-zone name      zone-name         PT, Pacific Time
     * z       time-zone name              zone-name         Pacific Standard Time; PST
     * O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
     * X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15
     * x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15
     * Z       zone-offset                 offset-Z          +0000; -0800; -08:00
     *
     * p       pad next                    pad modifier      1
     *
     * '       escape for text             delimiter
     * ''      single quote                literal           '
     * [       optional section start
     * ]       optional section end
     * #       reserved for future use
     * {       reserved for future use
     * }       reserved for future use
     * </pre>
     *
     *
     * The count of pattern letters determine the format.
     * See [DateTimeFormatter](DateTimeFormatter.html#patterns) for a user-focused description of the patterns.
     * The following tables define how the pattern letters map to the builder.
     *
     *
     * **Date fields**: Pattern letters to output a date.
     * <pre>
     * Pattern  Count  Equivalent builder methods
     * -------  -----  --------------------------
     * G       1      appendText(ChronoField.ERA, TextStyle.SHORT)
     * GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)
     * GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)
     * GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)
     * GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)
     *
     * u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL)
     * uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000)
     * uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL)
     * u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD)
     * y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL)
     * yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000)
     * yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL)
     * y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD)
     * Y       1      append special localized WeekFields element for numeric week-based-year
     * YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits
     * YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL)
     * Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD)
     *
     * Q       1      appendValue(IsoFields.QUARTER_OF_YEAR)
     * QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2)
     * QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)
     * QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)
     * QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)
     * q       1      appendValue(IsoFields.QUARTER_OF_YEAR)
     * qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2)
     * qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)
     * qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)
     * qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)
     *
     * M       1      appendValue(ChronoField.MONTH_OF_YEAR)
     * MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2)
     * MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)
     * MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)
     * MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)
     * L       1      appendValue(ChronoField.MONTH_OF_YEAR)
     * LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2)
     * LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)
     * LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)
     * LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)
     *
     * w       1      append special localized WeekFields element for numeric week-of-year
     * ww      2      append special localized WeekFields element for numeric week-of-year, zero-padded
     * W       1      append special localized WeekFields element for numeric week-of-month
     * d       1      appendValue(ChronoField.DAY_OF_MONTH)
     * dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)
     * D       1      appendValue(ChronoField.DAY_OF_YEAR)
     * DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2, 3, SignStyle.NOT_NEGATIVE)
     * DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)
     * F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)
     * g..g    1..n   appendValue(JulianFields.MODIFIED_JULIAN_DAY, n, 19, SignStyle.NORMAL)
     * E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     * EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     * EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     * EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
     * EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
     * e       1      append special localized WeekFields element for numeric day-of-week
     * ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded
     * eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     * eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
     * eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
     * c       1      append special localized WeekFields element for numeric day-of-week
     * ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)
     * cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)
     * ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE)
     * </pre>
     *
     *
     * **Time fields**: Pattern letters to output a time.
     * <pre>
     * Pattern  Count  Equivalent builder methods
     * -------  -----  --------------------------
     * a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)
     * h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)
     * hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)
     * H       1      appendValue(ChronoField.HOUR_OF_DAY)
     * HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)
     * k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)
     * kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)
     * K       1      appendValue(ChronoField.HOUR_OF_AMPM)
     * KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)
     * m       1      appendValue(ChronoField.MINUTE_OF_HOUR)
     * mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)
     * s       1      appendValue(ChronoField.SECOND_OF_MINUTE)
     * ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)
     *
     * S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)
     * A..A    1..n   appendValue(ChronoField.MILLI_OF_DAY, n, 19, SignStyle.NOT_NEGATIVE)
     * n..n    1..n   appendValue(ChronoField.NANO_OF_SECOND, n, 19, SignStyle.NOT_NEGATIVE)
     * N..N    1..n   appendValue(ChronoField.NANO_OF_DAY, n, 19, SignStyle.NOT_NEGATIVE)
     * </pre>
     *
     *
     * **Zone ID**: Pattern letters to output `ZoneId`.
     * <pre>
     * Pattern  Count  Equivalent builder methods
     * -------  -----  --------------------------
     * VV      2      appendZoneId()
     * v       1      appendGenericZoneText(TextStyle.SHORT)
     * vvvv    4      appendGenericZoneText(TextStyle.FULL)
     * z       1      appendZoneText(TextStyle.SHORT)
     * zz      2      appendZoneText(TextStyle.SHORT)
     * zzz     3      appendZoneText(TextStyle.SHORT)
     * zzzz    4      appendZoneText(TextStyle.FULL)
     * </pre>
     *
     *
     * **Zone offset**: Pattern letters to output `ZoneOffset`.
     * <pre>
     * Pattern  Count  Equivalent builder methods
     * -------  -----  --------------------------
     * O       1      appendLocalizedOffset(TextStyle.SHORT)
     * OOOO    4      appendLocalizedOffset(TextStyle.FULL)
     * X       1      appendOffset("+HHmm","Z")
     * XX      2      appendOffset("+HHMM","Z")
     * XXX     3      appendOffset("+HH:MM","Z")
     * XXXX    4      appendOffset("+HHMMss","Z")
     * XXXXX   5      appendOffset("+HH:MM:ss","Z")
     * x       1      appendOffset("+HHmm","+00")
     * xx      2      appendOffset("+HHMM","+0000")
     * xxx     3      appendOffset("+HH:MM","+00:00")
     * xxxx    4      appendOffset("+HHMMss","+0000")
     * xxxxx   5      appendOffset("+HH:MM:ss","+00:00")
     * Z       1      appendOffset("+HHMM","+0000")
     * ZZ      2      appendOffset("+HHMM","+0000")
     * ZZZ     3      appendOffset("+HHMM","+0000")
     * ZZZZ    4      appendLocalizedOffset(TextStyle.FULL)
     * ZZZZZ   5      appendOffset("+HH:MM:ss","Z")
     * </pre>
     *
     *
     * **Modifiers**: Pattern letters that modify the rest of the pattern:
     * <pre>
     * Pattern  Count  Equivalent builder methods
     * -------  -----  --------------------------
     * [       1      optionalStart()
     * ]       1      optionalEnd()
     * p..p    1..n   padNext(n)
     * </pre>
     *
     *
     * Any sequence of letters not specified above, unrecognized letter or
     * reserved character will throw an exception.
     * Future versions may add to the set of patterns.
     * It is recommended to use single quotes around all characters that you want
     * to output directly to ensure that future changes do not break your application.
     *
     *
     * Note that the pattern string is similar, but not identical, to
     * [SimpleDateFormat][java.text.SimpleDateFormat].
     * The pattern string is also similar, but not identical, to that defined by the
     * Unicode Common Locale Data Repository (CLDR/LDML).
     * Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML.
     * By contrast, `SimpleDateFormat` uses 'u' for the numeric day of week.
     * Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently.
     * Pattern letters 'n', 'A', 'N', and 'p' are added.
     * Number types will reject large numbers.
     *
     * @param pattern  the pattern to add, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the pattern is invalid
     */
    fun appendPattern(pattern: String): DateTimeFormatterBuilder {
        parsePattern(pattern)
        return this
    }

    private fun parsePattern(pattern: String) {
        var pos = 0
        while (pos < pattern.length) {
            var cur = pattern[pos]
            if ((cur in 'A'..'Z') || (cur in 'a'..'z')) {
                var start = pos
                pos += 1
                while (pos < pattern.length && pattern[pos] == cur) {
                    pos += 1
                }  // short loop
                var count = pos - start
                // padding
                if (cur == 'p') {
                    var pad = 0
                    if (pos < pattern.length) {
                        cur = pattern[pos]
                        if ((cur in 'A'..'Z') || (cur in 'a'..'z')) {
                            pad = count
                            start = pos
                            while (pos < pattern.length && pattern[pos] == cur) {
                                pos += 1
                            } // short loop
                            count = pos - start
                        }
                    }
                    if (pad == 0) {
                        throw IllegalArgumentException(
                            "Pad letter 'p' must be followed by valid pad pattern: $pattern"
                        )
                    }
                    padNext(pad) // pad and continue parsing
                }
                // main rules
                val field = FIELD_MAP.get(cur)
                if (field != null) {
                    parseField(cur, count, field)
                } else if (cur == 'z') {
                    if (count > 4) {
                        throw IllegalArgumentException("Too many pattern letters: $cur")
                    } else if (count == 4) {
                        appendZoneText(TextStyle.FULL)
                    } else {
                        appendZoneText(TextStyle.SHORT)
                    }
                } else if (cur == 'V') {
                    if (count != 2) {
                        throw IllegalArgumentException("Pattern letter count must be 2: $cur")
                    }
                    appendZoneId()
                } else if (cur == 'v') {
                    if (count == 1) {
                        appendGenericZoneText(TextStyle.SHORT)
                    } else if (count == 4) {
                        appendGenericZoneText(TextStyle.FULL)
                    } else {
                        throw IllegalArgumentException("Wrong number of  pattern letters: $cur")
                    }
                } else if (cur == 'Z') {
                    if (count < 4) {
                        appendOffset("+HHMM", "+0000")
                    } else if (count == 4) {
                        appendLocalizedOffset(TextStyle.FULL)
                    } else if (count == 5) {
                        appendOffset("+HH:MM:ss","Z")
                    } else {
                        throw IllegalArgumentException("Too many pattern letters: $cur")
                    }
                } else if (cur == 'O') {
                    if (count == 1) {
                        appendLocalizedOffset(TextStyle.SHORT)
                    } else if (count == 4) {
                        appendLocalizedOffset(TextStyle.FULL)
                    } else {
                        throw IllegalArgumentException("Pattern letter count must be 1 or 4: $cur")
                    }
                } else if (cur == 'X') {
                    if (count > 5) {
                        throw IllegalArgumentException("Too many pattern letters: $cur")
                    }
                    appendOffset(OffsetIdPrinterParser.PATTERNS[count + if (count == 1) 0 else 1], "Z")
                } else if (cur == 'x') {
                    if (count > 5) {
                        throw IllegalArgumentException("Too many pattern letters: $cur")
                    }
                    val zero = if (count == 1) "+00" else if (count % 2 == 0) "+0000" else "+00:00"
                    appendOffset(OffsetIdPrinterParser.PATTERNS[count + if (count == 1) 0 else 1], zero)
                } else if (cur == 'W') {
                    // Fields defined by Locale
                    if (count > 1) {
                        throw IllegalArgumentException("Too many pattern letters: $cur")
                    }
                    appendValue(WeekBasedFieldPrinterParser(cur, count, count, count))
                } else if (cur == 'w') {
                    // Fields defined by Locale
                    if (count > 2) {
                        throw IllegalArgumentException("Too many pattern letters: $cur")
                    }
                    appendValue(WeekBasedFieldPrinterParser(cur, count, count, 2))
                } else if (cur == 'Y') {
                    // Fields defined by Locale
                    if (count == 2) {
                        appendValue(WeekBasedFieldPrinterParser(cur, count, count, 2))
                    } else {
                        appendValue(WeekBasedFieldPrinterParser(cur, count, count, 19))
                    }
                } else {
                    throw IllegalArgumentException("Unknown pattern letter: $cur")
                }
                pos -= 1
            } else if (cur == '\'') {
                // parse literals
                val start = pos
                pos += 1
                while (pos < pattern.length) {
                    if (pattern[pos] == '\'') {
                        if (pos + 1 < pattern.length && pattern[pos + 1] == '\'') {
                            pos += 1
                        } else {
                            break  // end of literal
                        }
                    }
                    pos += 1
                }
                if (pos >= pattern.length) {
                    throw IllegalArgumentException("Pattern ends with an incomplete string literal: $pattern")
                }
                val str = pattern.substring(start + 1, pos)
                if (str.isEmpty()) {
                    appendLiteral('\'')
                } else {
                    appendLiteral(str.replace("''", "'"))
                }

            } else if (cur == '[') {
                optionalStart()

            } else if (cur == ']') {
                if (active.parent == null) {
                    throw IllegalArgumentException("Pattern invalid as it contains ] without previous [")
                }
                optionalEnd()

            } else if (cur == '{' || cur == '}' || cur == '#') {
                throw IllegalArgumentException("Pattern includes reserved character: '$cur'")
            } else {
                appendLiteral(cur)
            }
            pos += 1
        } // while (pos < pattern.length)
    }

    //-----------------------------------------------------------------------
    /**
     * Mark the start of an optional section.
     *
     *
     * The output of formatting can include optional sections, which may be nested.
     * An optional section is started by calling this method and ended by calling
     * [.optionalEnd] or by ending the build process.
     *
     *
     * All elements in the optional section are treated as optional.
     * During formatting, the section is only output if data is available in the
     * `TemporalAccessor` for all the elements in the section.
     * During parsing, the whole section may be missing from the parsed string.
     *
     *
     * For example, consider a builder setup as
     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)`.
     * The optional section ends automatically at the end of the builder.
     * During formatting, the minute will only be output if its value can be obtained from the date-time.
     * During parsing, the input will be successfully parsed whether the minute is present or not.
     *
     * @return this, for chaining, not null
     */
    fun optionalStart(): DateTimeFormatterBuilder {
        active.valueParserIndex = -1
        active = DateTimeFormatterBuilder(active, true)
        return this
    }

    /**
     * Ends an optional section.
     *
     *
     * The output of formatting can include optional sections, which may be nested.
     * An optional section is started by calling [.optionalStart] and ended
     * using this method (or at the end of the builder).
     *
     *
     * Calling this method without having previously called `optionalStart`
     * will throw an exception.
     * Calling this method immediately after calling `optionalStart` has no effect
     * on the formatter other than ending the (empty) optional section.
     *
     *
     * All elements in the optional section are treated as optional.
     * During formatting, the section is only output if data is available in the
     * `TemporalAccessor` for all the elements in the section.
     * During parsing, the whole section may be missing from the parsed string.
     *
     *
     * For example, consider a builder setup as
     * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()`.
     * During formatting, the minute will only be output if its value can be obtained from the date-time.
     * During parsing, the input will be successfully parsed whether the minute is present or not.
     *
     * @return this, for chaining, not null
     * @throws IllegalStateException if there was no previous call to `optionalStart`
     */
    fun optionalEnd(): DateTimeFormatterBuilder {
        if (active.parent == null) {
            throw IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()")
        }
        if (active.printerParsers.size > 0) {
            val cpp = CompositePrinterParser(active.printerParsers, active.optional)
            active = active.parent!!
            appendInternal(cpp)
        } else {
            active = active.parent!!
        }
        return this
    }

    /**
     * Appends a fixed or variable width printer-parser handling adjacent value mode.
     * If a PrinterParser is not active then the new PrinterParser becomes
     * the active PrinterParser.
     * Otherwise, the active PrinterParser is modified depending on the new PrinterParser.
     * If the new PrinterParser is fixed width and has sign style {@code NOT_NEGATIVE}
     * then its width is added to the active PP and
     * the new PrinterParser is forced to be fixed width.
     * If the new PrinterParser is variable width, the active PrinterParser is changed
     * to be fixed width and the new PrinterParser becomes the active PP.
     *
     * @param pp  the printer-parser, not null
     * @return this, for chaining, not null
     */
    private fun appendValue(pp: NumberPrinterParser): DateTimeFormatterBuilder {
        if (this.active.valueParserIndex >= 0) {
            val activeValueParser = this.active.valueParserIndex

            // adjacent parsing mode, update setting in previous parsers
            var basePP = this.active.printerParsers.get(activeValueParser) as NumberPrinterParser
            if (pp.minWidth == pp.maxWidth && pp.signStyle == SignStyle.NOT_NEGATIVE) {
                // Append the width to the subsequentWidth of the active parser
                basePP = basePP.withSubsequentWidth(pp.maxWidth)
                // Append the new parser as a fixed width
                appendInternal(pp.withFixedWidth())
                // Retain the previous active parser
                this.active.valueParserIndex = activeValueParser
            } else {
                // Modify the active parser to be fixed width
                basePP = basePP.withFixedWidth()
                // The new parser becomes the mew active parser
                this.active.valueParserIndex = appendInternal(pp)
            }
            // Replace the modified parser with the updated one
            this.active.printerParsers.set(activeValueParser, basePP)
        } else {
            // The new Parser becomes the active parser
            this.active.valueParserIndex = appendInternal(pp)
        }
        return this
    }

    //-----------------------------------------------------------------------
    /**
     * Appends a printer and/or parser to the internal list handling padding.
     *
     * @param pp  the printer-parser to add, not null
     * @return the index into the active parsers list
     */
    private fun appendInternal(pp: DateTimePrinterParser?): Int {
        var pp = pp
        if (active.padNextWidth > 0) {
            if (pp != null) {
                pp = PadPrinterParserDecorator(pp, active.padNextWidth, active.padNextChar)
            }
            this.active.padNextWidth = 0
            this.active.padNextChar = 0.toChar()
        }
        this.active.printerParsers.add(pp)
        this.active.valueParserIndex = -1
        return this.active.printerParsers.size - 1
    }
}